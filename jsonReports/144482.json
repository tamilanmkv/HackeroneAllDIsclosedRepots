{"id":144482,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xNDQ0ODI=","url":"https://hackerone.com/reports/144482","title":"StringIO strio_getline() can divulge arbitrary memory","state":"Closed","substate":"resolved","readable_substate":"Resolved","created_at":"2016-06-13T14:39:10.077Z","submitted_at":"2016-06-13T14:39:10.077Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"guido","url":"/guido","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/43e4513b9104ea0d68c9c096cea374ba8440dde3e027af5465c8771e8839a67c"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":7724,"url":"https://hackerone.com/ruby","handle":"ruby","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/007/724/bb067434deef370d6a0b16c2cbbc030b57c75e92_original.png/43e4513b9104ea0d68c9c096cea374ba8440dde3e027af5465c8771e8839a67c","medium":"https://profile-photos.hackerone-user-content.com/variants/000/007/724/bb067434deef370d6a0b16c2cbbc030b57c75e92_original.png/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"pentest_feature_enabled?":false,"profile":{"name":"Ruby","twitter_handle":"","website":"https://www.ruby-lang.org","about":"A Programmer's Best Friend"}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"has_collaborators":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2016-06-21T00:56:33.515Z","bug_reporter_agreed_on_going_public_at":"2016-06-17T23:49:48.746Z","team_member_agreed_on_going_public_at":"2016-06-21T00:56:27.877Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"(originally send by e-mail on 4 Jun 2016)\n\nThe problem is this line in ext/stringio/stringio.c strio_getline():\n\n```c\n1002     if (limit \u003e 0 \u0026\u0026 s + limit \u003c e) {\n1003     e = rb_enc_right_char_head(s, s + limit, e, get_enc(ptr));\n1004     }\n```\n\nThis works as intended as long as the sum of s (pointer) and limit\n(long) doesn't overflow. So if on a 32 bit system 's' happens to be\n0xBF000000, and limit is 0x7FFFFFFF, the sum of both values is\n0x3EFFFFFF, which is a completely unrelated address. From there, there\nare several paths to be chosen from based on what the first parameter to\nthe function is ('str').\n\n```c\n  1005\t    if (NIL_P(str)) {\n            ...\n            ...\n  1008\t    else if ((n = RSTRING_LEN(str)) == 0) {\n            ...\n            ...\n  1024\t    else if (n == 1) {\n            ...\n            ...\n  1030\t    else {\n            ...\n            ...\n```\n\nAll these paths eventually call strio_substr(). A wrong 'pos' parameter\nto this function is not possible because it was checked earlier:\n\n```c\n   996\t    if (ptr-\u003epos \u003e= (n = RSTRING_LEN(ptr-\u003estring))) {\n   997\t\treturn Qnil;\n   998\t    }\n```\n\na wrong 'len' parameter to this function doesn't matter as it will\ncorrect it itself:\n\n```c\n    98\tstatic VALUE\n    99\tstrio_substr(struct StringIO *ptr, long pos, long len)\n   100\t{\n   101\t    VALUE str = ptr-\u003estring;\n   102\t    rb_encoding *enc = get_enc(ptr);\n   103\t    long rlen = RSTRING_LEN(str) - pos;\n   104\t\n   105\t    if (len \u003e rlen) len = rlen;\n   106\t    if (len \u003c 0) len = 0;\n   107\t    if (len == 0) return rb_str_new(0,0);\n   108\t    return rb_enc_str_new(RSTRING_PTR(str)+pos, len, enc);\n   109\t}\n```\n\nAs for the first path ('str' is nil, line 1005), it will call\nstrio_substr() with an invalid 'len' value, which doesn't matter because\nstrio_substr() corrects it:\n\n```c\n  1005\t    if (NIL_P(str)) {\n  1006\t\tstr = strio_substr(ptr, ptr-\u003epos, e - s);\n  1007\t    }\n```\n\nWithin the second path ('str' is an empty string, line 1008), there is\nthe risk of an OOB read here, because this routine's logic is based on\nthe belief that 'e' denotes the end of the buffer. 'p' will never become\n'e' because either 1) a null pointer dereference will occur (once it\nreads at address 0x00000000) or 2) no \\n character is found before 'p'\nreaches an invalid memory page. In theory an attacker could use this\nmishap to find the \\n character at various places in memory (by\nadjusting the 'limit' variable), but that is usually not very useful.\n(The way an attacker can know at which the \\n character is found will\nbecome clear later).\n\n```c\n  1009\t\tp = s;\n  1010\t\twhile (*p == '\\n') {\n  1011\t\t    if (++p == e) {\n  1012\t\t\treturn Qnil;\n  1013\t\t    }\n  1014\t\t}\n  1015\t\ts = p;\n  1016\t\twhile ((p = memchr(p, '\\n', e - p)) \u0026\u0026 (p != e)) {\n  1017\t\t    if (*++p == '\\n') {\n  1018\t\t\te = p + 1;\n  1019\t\t\tbreak;\n  1020\t\t    }\n  1021\t\t}\n  1022\t\tstr = strio_substr(ptr, s - RSTRING_PTR(ptr-\u003estring), e - s);\n```\n\nThe third path ('str' is 1 character large, line 1024) is similar to the\nsecond path except that memchr is used to find the desired character:\n\n```c\n  1025\t\tif ((p = memchr(s, RSTRING_PTR(str)[0], e - s)) != 0) {\n  1026\t\t    e = p + 1;\n  1027\t\t}\n  1028\t\tstr = strio_substr(ptr, ptr-\u003epos, e - s);\n```\n\nThe fourth path is entered if 'str' is 2 or more bytes large (line\n1030). The first condition is always true if a very high 'limit' value\nis chosen (the premise of this vulnerability):\n\n```c\n  1031\t\tif (n \u003c e - s) {\n```\n\nThe first subpath is never true in this case:\n\n```c\n  1032\t\t    if (e - s \u003c 1024) {\n```\n\nSo the second subpath is entered. This can be used to find the arbitrary\nstring 'str' across the totality of virtual memory:\n\n```c\n  1040\t\t    else {\n  1041\t\t\tlong skip[1 \u003c\u003c CHAR_BIT], pos;\n  1042\t\t\tp = RSTRING_PTR(str);\n  1043\t\t\tbm_init_skip(skip, p, n);\n  1044\t\t\tif ((pos = bm_search(p, n, s, e - s, skip)) \u003e= 0) {\n  1045\t\t\t    e = s + pos + n;\n  1046\t\t\t}\n  1047\t\t    }\n```\n\nAfter any of these paths have been traversed, the attacker can read the\n'pos' attribute to get the relative location of the string that has been\nfound somewhere in memory:\n\n```c\n  1051\t    ptr-\u003epos = e - RSTRING_PTR(ptr-\u003estring);\n```\n\nBy subtracting this current 'pos' from the previous 'pos' the attacker\ncan know the position of string that was searched for relative to the\nbase string.\n\nMy hypothesis is that, if we assume that the attacker can control the\n'limit' variable as well as the string that has to be searched for and\nthey can invoke strio_getline an arbitrary number of times, they can\nmake Ruby divulge arbitrary information such as private keys (if they\nare loaded in memory), by searching for 'BEGIN PGP PRIVATE KEY BLOCK'\nand adjust the 'limit' parameter in combination with all alphanumeric\ncharacters to deduce the entire base64-encoded private key.\n\nNote that a pointer address can naturally be very high (on 32 bit\nanyway), such as 0xFFFF0000. In that event, a 'limit' of 0x10000 can be\nenough to overflow this computation:\n\n```c\n1002     if (limit \u003e 0 \u0026\u0026 s + limit \u003c e) {\n```\n\nHere is code that can be used to trigger the vulnerability.\n\n```ruby\nrequire \"stringio\"\ns = StringIO.new\ns.puts(\"abc\")\ns.rewind()\nx = s.gets('xxx', 0x7FFFFFFFFFFFFFF0)\nputs(s.pos)\n```\n\nThe vulnerability is more likely to trigger on 32 bit than on 64 bit,\nsince on 32 bit, the chance that the base string is allocated beyond the\nhalf of the virtual address space (0x80000000 or above, like 0xBF000000\nin my initial example) than on 64 bit (where it needs to be allocated at\n0x8000000000000000 or above). I did all of my testing on 32 bit.\n\nPlease let me know if you request a CVE, or if you need more information\nfrom me.\n\nGuido","bounty_amount":"500.0","formatted_bounty":"$500","weakness":{"id":2,"name":"Memory Corruption - Generic"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2016-07-17T23:49:48.859Z","allow_singular_disclosure_after":-165160327.95409912,"singular_disclosure_allowed":true,"vote_count":13,"voters":["lukasreschke","mdv","guido","zawad","temmyscript","kaito","mogyhacker","martijn","zeroknife","dyabla","and 3 more..."],"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"activities":[{"id":1012197,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"We couldn't reproduce this bug with the PoC code, but confirmed the case.\nThe assumption doesn't seem a common case, but we don't assert it is impossible.\n\nWe are discussing how to handle this issue.","automated_response":false,"created_at":"2016-06-13T23:56:57.613Z","updated_at":"2016-06-13T23:56:57.613Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1016514,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"We reproduced the problem on 32bit box, but will not provide emergency releases for this issue because the assumption in your report is not impossible but unlikely in real-world applications.\n\nThe following fix will be included in the next releases of 2.2, 2.3, and 2.4:\n\n```\ndiff --git a/ext/stringio/stringio.c b/ext/stringio/stringio.c\nindex 4fdc4df..f35c702 100644\n--- a/ext/stringio/stringio.c\n+++ b/ext/stringio/stringio.c\n@@ -1021,7 +1021,7 @@ strio_getline(int argc, VALUE *argv, struct StringIO *ptr)\n     s = RSTRING_PTR(ptr-\u003estring);\n     e = s + RSTRING_LEN(ptr-\u003estring);\n     s += ptr-\u003epos;\n-    if (limit \u003e 0 \u0026\u0026 s + limit \u003c e) {\n+    if (limit \u003e 0 \u0026\u0026 (size_t)limit \u003c (size_t)(e - s)) {\n    e = rb_enc_right_char_head(s, s + limit, e, get_enc(ptr));\n     }\n     if (NIL_P(str)) {\n```\n\nThank you for your cooperation.","automated_response":false,"created_at":"2016-06-16T07:06:23.899Z","updated_at":"2016-06-16T07:06:23.899Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1017098,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Okay. I guess you can close this one as resolved then.","automated_response":false,"created_at":"2016-06-16T11:48:37.922Z","updated_at":"2016-06-16T11:48:37.922Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1017372,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"@guido Done. Thank you. ","automated_response":false,"created_at":"2016-06-16T14:47:44.807Z","updated_at":"2016-06-16T14:47:44.807Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"guido","url":"/guido"},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1018114,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Is there an embargo on this, ie. should I refrain from talking about this publicly?","automated_response":false,"created_at":"2016-06-16T21:33:29.791Z","updated_at":"2016-06-16T21:33:29.791Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1018425,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"\u003e Is there an embargo on this, ie. should I refrain from talking about this publicly?\n\nNo, feel free to talk about it publicly.\n\nFYI, the fix is not committed yet, because the following test passes without the fix:\n\n```\ndiff --git a/test/stringio/test_stringio.rb b/test/stringio/test_stringio.rb\nindex bf3a9ee..e4974cb 100644\n--- a/test/stringio/test_stringio.rb\n+++ b/test/stringio/test_stringio.rb\n@@ -680,4 +680,11 @@\n       StringIO.new {}\n     end\n   end\n+\n+  def test_overflow\n+    limit = (1 \u003c\u003c (RbConfig::SIZEOF[\"size_t\"]*8-1)) - 0x10\n+    s = StringIO.new(\"abc\\n\")\n+    s.gets(\"xxx\", limit)\n+    assert_equal(4, s.pos)\n+  end\n end\n```\n\nDo you have any suggestion?\n","automated_response":false,"created_at":"2016-06-17T02:24:31.050Z","updated_at":"2016-06-17T02:24:31.050Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1018917,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"I haven't tried your test but the reason that any test you'll make for this can always fail is because:\n\n```c\n     if (limit \u003e 0 \u0026\u0026 s + limit \u003c e) {\n```\n\nIf ```s``` is a pointer whose virtual address is below 0x80000000, then ```s + limit \u003c e``` will work as expected, because ```s + 0x80000000``` does not overflow the register on 32 bit.\n\nSay ```s``` is ```0x70000000``` and ```e``` is 0x70001000```, and ```limit``` is ```0x7FFFFFF0```.  So you will get:\n\n```c\n     if 0x7FFFFFF0 \u003e 0 \u0026\u0026 0x70000000 + 0x7FFFFFF0 \u003c 0x70001000  ) {\n```\n\nBecause ```0x70000000 + 0x7FFFFFF0``` does NOT overflow but rather computes to the correct value ```0xEFFFFFF0```, the code works as expected: ```0xEFFFFFF0``` is NOT lower than ```0x70001000``` so the code within the curly braces ```{}``` will not get executed.\n\nCompare this to a scenario where ```s``` is ```0x8000000F``` or higher.\nFor example:\n\n```s == 0x90000000```\n```e == 0x90001000```\n```limit == 0x7FFFFFF0```\n\n```s + limit \u003c e```` evaluates to\n```0x90000000 + 0x7FFFFFF0 \u003c 0x90001000``` which evaluates to\n```0x0FFFFFF0 \u003c 0x90001000``` which evaluates as true, thus the code within the curly braces ```{}``` will be executed. This is the actual culprit in the vulnerability.\n\nSince there is no way to influence at which virtual addresses ```malloc()```  puts allocates blocks, and as far as I know you cannot set the ```limit``` (the second parameter to ```gets()```) to something like ```0xFFFFFFFF``` (this would 100% ensure the vulnerability to trigger), it is not possible to design a fully reliable test.","automated_response":false,"created_at":"2016-06-17T11:45:10.616Z","updated_at":"2016-06-17T11:45:10.616Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1020460,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","automated_response":false,"created_at":"2016-06-17T23:49:48.786Z","updated_at":"2016-06-17T23:49:48.786Z","first_to_agree":true,"actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1020531,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"@guido \nThanks for your advice.\n\nRunning a different Ruby process from a test also doesn't reproduce the problem, so we've just merged it.","automated_response":false,"created_at":"2016-06-18T01:02:55.957Z","updated_at":"2016-06-18T01:02:55.957Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1025850,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","automated_response":false,"created_at":"2016-06-21T00:56:27.922Z","updated_at":"2016-06-21T00:56:27.922Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1025851,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","automated_response":false,"created_at":"2016-06-21T00:56:33.542Z","updated_at":"2016-06-21T00:56:33.542Z","actor":{"username":"shugo","cleared":false,"url":"/shugo","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/076/177/c63f990ae1ef62a77c2ff1e5b2db5e4dd3db2557_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":1028246,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"We're assessing the minimum bounty here given the complexity and number of constraints involved in achieving exploitation on most production systems. Thanks for the detailed description as always @guido! ","automated_response":false,"created_at":"2016-06-22T13:28:19.650Z","updated_at":"2016-06-22T13:28:19.650Z","actor":{"url":"/ruby","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/007/724/bb067434deef370d6a0b16c2cbbc030b57c75e92_original.png/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"profile":{"name":"Ruby"}},"bounty_amount":"500.0","bounty_currency":"usd","genius_execution_id":null,"team_handle":"ruby","collaborator":{"username":"guido","url":"/guido"},"actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1028254,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks!","automated_response":false,"created_at":"2016-06-22T13:34:12.609Z","updated_at":"2016-06-22T13:34:12.609Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"ruby","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}