{"id":138025,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xMzgwMjU=","url":"https://hackerone.com/reports/138025","title":"Heap corruption via memarea.c","state":"Closed","substate":"resolved","readable_substate":"Resolved","created_at":"2016-05-11T20:00:34.272Z","submitted_at":"2016-05-11T20:00:34.272Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"guido","url":"/guido","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/43e4513b9104ea0d68c9c096cea374ba8440dde3e027af5465c8771e8839a67c"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":1800,"url":"https://hackerone.com/torproject","handle":"torproject","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/001/800/6e575d0a9127b91e83833cf4a9e6be6e8b30cbc3_original.jpg/43e4513b9104ea0d68c9c096cea374ba8440dde3e027af5465c8771e8839a67c","medium":"https://profile-photos.hackerone-user-content.com/variants/000/001/800/6e575d0a9127b91e83833cf4a9e6be6e8b30cbc3_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"pentest_feature_enabled?":false,"profile":{"name":"Tor","twitter_handle":"torproject","website":"https://www.torproject.org/","about":"Anonymity Online"}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"has_collaborators":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2017-10-19T10:16:01.417Z","bug_reporter_agreed_on_going_public_at":"2017-10-19T10:16:01.366Z","team_member_agreed_on_going_public_at":"2017-10-19T09:35:39.803Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"Hello again,\n\nThere is a potential vulnerability in memarea.c.\n\ncommon/memarea.c:\n\n```c\n230 void *\n231 memarea_alloc(memarea_t *area, size_t sz)\n232 {\n233   memarea_chunk_t *chunk = area-\u003efirst;\n234   char *result;\n235   tor_assert(chunk);\n236   CHECK_SENTINEL(chunk);\n237   tor_assert(sz \u003c SIZE_T_CEILING);\n238   if (sz == 0)\n239     sz = 1;\n240   if (chunk-\u003enext_mem+sz \u003e chunk-\u003eU_MEM+chunk-\u003emem_size) {\n```\n\nThe vulnerability lies in the addition of a pointer and an integer on line 240:\n\n```c\n240   if (chunk-\u003enext_mem+sz ...\n```\nTo which address ```chunk-\u003enext_mem``` points is not within the application's (tor) purview, since it originates from within malloc() (which is accessed via tor_malloc()) and to some extent the system's kernel memory management), and malloc() is implemented in the libc with which tor was linked.\nMy point is that no or few assumptions can be made about the virtual address to which chunk-\u003enext_mem points.\n\n```sz``` is variable and may be influenced by an external party on the network.\n\nFurthermore, it is guaranteed that ```sz``` is smaller than SIZE_T_CEILING, which is 0x80000000 on 32 bit:\n\n```c\ntor_assert(sz \u003c SIZE_T_CEILING);\n```\n\nThe above predicates imply that 1) given a 32 bit system, where 2) chunk-\u003enext_mem happens to point to a virtual address of 0x80000000 or higher and 3) ```sz``` \u003e= ```0x100000000 - chunk-\u003emem_next``` an overflow will occur in the addition of the pointer ```chunk-\u003enext_mem+sz```, thus unduly evading this check, which was meant to assert whether is sufficient memory in the current block.\n\nIn other words, if chunk-\u003enext_mem is 0xA0000000, and memarea_alloc is called to request ```0x60000000``` bytes, then the following will happen:\n\n```c\n230 void *\n231 memarea_alloc(memarea_t *area, size_t sz)\n232 {     \n233   memarea_chunk_t *chunk = area-\u003efirst;\n234   char *result;\n235   tor_assert(chunk);\n236   CHECK_SENTINEL(chunk);\n237   tor_assert(sz \u003c SIZE_T_CEILING);\n238   if (sz == 0)\n239     sz = 1;\n240   if (chunk-\u003enext_mem+sz \u003e chunk-\u003eU_MEM+chunk-\u003emem_size) {\n...\n...   This code is not executed\n...\n254   } \n255   result = chunk-\u003enext_mem;\n256   chunk-\u003enext_mem = chunk-\u003enext_mem + sz;\n```\n\nIn this case, line 256 translate to:\n\n```\n256   chunk-\u003enext_mem = 0xA0000000 + 0x60000000;\n```\n\nEg. ```chunk-\u003enext_mem``` now equals 0.\n\nThe higher the value of ```chunk-\u003enext_mem```, and the higher the maximum value of ```sz``` that a potential attacker can enforce to be allocated, the higher the odds of yielding a ```chunk-\u003enext_mem``` value that points to real data (eg. a block of heap memory allocated by tor).\n\nI've used 32 bit in this example. 64 bit is theoretically possible too (SIZE_T_CEILING is larger on 64 bit as well), but less likely.\n\nAn easy way to test this is by changing this line in memarea.c alloc_chunk():\n\n```c\nres = tor_malloc(chunk_size);\n```\n\nto\n\n```c\nres = mmap((void*)0xF0000000, chunk_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n```\n\n(also include ```#include \u003csys/mman.h\u003e```)\n\nthen this code will trigger a segmentation fault\n\n```\n  memarea_t *area;\n  area = memarea_new();\n  char *mem = memarea_alloc(area, 0x10000000);\n  memset(mem, 0, 0x10000000);\n```\n\n(be aware that this example applies to 32 bit, so compile with ```CFLAGS=\"-m32\"```)\n\nGuido","bounty_amount":"300.0","formatted_bounty":"$300","weakness":{"id":2,"name":"Memory Corruption - Generic"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2017-11-18T09:35:40.030Z","allow_singular_disclosure_after":-122961857.49448499,"singular_disclosure_allowed":true,"vote_count":6,"voters":["geeknik","eveeez","mr_r3boot","spetr0x","b4155f7c29acd42c27d007a","mycel"],"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"activities":[{"id":962155,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hey Guido!\n\nThanks for the bug report!\n\nThis does sound like a pretty bad bug, but I actually can't find a way to exploit it the way you describe. That is, I can't find a vector where `memarea_alloc()` is called with a dangerously big `sz` argument.\n\nSpecifically, the function seems to get used a lot in `routerparse.c:get_next_token()` but it seems like all its inputs are restricted to 128kb, that is `MAX_LINE_LENGTH` and `MAX_UNPARSED_OBJECT_SIZE`.\nSo we are talking about `sz` arguments of value 131072 or so, which is nowhere close to the `0x60000000` you provided :/\n\nI feel that this bug should be fixed for sure, but I doubt it can actually be exploitable for RCE. How would you exploit this bug? I am tempted to rank this as a \"low severity\" issue if no plausible attack vector is provided.\n\nAlso, how would you fix this bug? Do you think we could just replace the overflowing pointer length check with something like `if sz \u003e chunk-\u003emem_size`?\n\nIn any case, I'll pipe this issue to more Tor developers.\n\nThanks for the report!","automated_response":false,"created_at":"2016-05-17T20:49:12.306Z","updated_at":"2016-05-17T20:49:12.306Z","actor":{"username":"asn","cleared":false,"url":"/asn","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":962281,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Hey asn,\n\nI agree that if 128kb is the largest size allocated via memarea, the worst that can happen is a remote denial of service (via a null pointer write).\n\nIf we assume that ```chunk-\u003enext_mem``` is 0xFFFE0000 or upward, and memarea_alloc is called with sz == 0x20000 (128 kilobyte), then\n\nthis:\n\n```c\nif (chunk-\u003enext_mem+sz \u003e chunk-\u003eU_MEM+chunk-\u003emem_size) { ... }\n```\n\nwill render to\n\n```c\nif ( 0 \u003e chunk-\u003eU_MEM+chunk-\u003emem_size ) { ... }\n```\n\nwhich is always false so\n\n```c\nchunk-\u003enext_mem = chunk-\u003enext_mem + sz;\n```\n\nbecomes\n\n```c\nchunk-\u003enext_mem = 0;\n```\n\nafter which a write to 0x00000000 or thereabouts is expected to happen, which would crash tor.\n\nSome notes:\n\nJust as there is (as far as I know) no strict limit to the maximum (highest) virtual address that malloc() may return, there may also not be a strict lower limit.\nmalloc(), or the system's low-level allocation facilities will never return a legal heap pointer to 0x00000000, as in:\n\n```c\nc = malloc(1024);\n/* c == 0x00000000 */\nmemset(c, 0, 1024);\n```\n\nBut it might be possible that malloc() would return a pointer to, say, 0x00010000.\n\nIf we assume for a moment that\n   - some unrelated function has some stored some data on 0x00010000\n   - chunk-\u003enext_mem is currently 0xFFFF0000 ,and chunk-\u003emem_size is some smallish amount.\n   - A call to memarea_alloc is made requesting a size of 128KB (0x20000)\n\nSince 0xFFFF0000 (start of current heap block) + 0x20000 (requested amount) overflows into 0xFFFF0000 + 0x200000 = 0x100010000 = 0x00010000 on a 32 bit system,\n\n```c\nif (chunk-\u003enext_mem+sz \u003e chunk-\u003eU_MEM+chunk-\u003emem_size) { ... }\n```\n\nbecomes\n\n```c\nif (0x00010000 \u003e chunk-\u003eU_MEM+chunk-\u003emem_size) { ... }\n```\n\nwhich is false,\n\nSo\n\n```c\nchunk-\u003enext_mem = chunk-\u003enext_mem + sz;\n```\n\nbecomes\n\n```c\nchunk-\u003enext_mem = 0x00010000;\n```\n\nwhich happens to be totally unrelated heap memory containing unrelated data in this example.\n\nAnyway, I think this example of potential RCE is a very arcane cornercase that would only be exploitable on a specific 32 bit architecture+kernel+libc that allows both very high virtual address allocations (0xFFFF0000) and very low virtual address allocations (0x00010000) (or static data residing there ).\n\nSo because there is a potential remote DoS, and fixing it may prevent an RCE if you will use memarea at more places in the future (ie. it's implementing a best practice/additional safety guard), and RCE is currently only possible in very unlikely scenario's (if at all), I fully agree with your grading of \"low severity\".\n\nI think your proposed fix ```if sz \u003e chunk-\u003emem_size``` is correct but I'm gonna double check that right now and I'll get back to it later.\n\nGuido","automated_response":false,"created_at":"2016-05-17T22:08:01.381Z","updated_at":"2016-05-17T22:08:01.381Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":966304,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Checking the size directly seems to be the way to go.\n\nIncidentally, someone wrote a blog post on the problem over pointer overflow checks a couple of days ago: https://blog.regehr.org/archives/1395 . In that article he argues that pointer additions resulting in a non-valid pointer address are in fact undefined behavior per the C standard, and while compilers work around this particular pattern introduced by the programmer to avoid problems, it seems that direct size checking (the solution you proposed) is actually the correct way to deal with these kinds of situations.","automated_response":false,"created_at":"2016-05-20T13:01:54.078Z","updated_at":"2016-05-20T13:01:54.078Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":969523,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":" Hello Guido!\n\nWe decided to award $300 to this vulnerability report, for its DoS implications and for future code correctness.\n\nThanks for the report!","automated_response":false,"created_at":"2016-05-23T08:23:37.499Z","updated_at":"2016-05-23T08:23:37.499Z","actor":{"url":"/torproject","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/001/800/6e575d0a9127b91e83833cf4a9e6be6e8b30cbc3_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"profile":{"name":"Tor"}},"bounty_amount":"300.0","bounty_currency":"usd","genius_execution_id":null,"team_handle":"torproject","collaborator":{"username":"guido","url":"/guido"},"actor_is_team_member":true,"actor_is_concealed_member":false},{"id":970592,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks!!\n\nPlease mark the report as 'resolved' when you're ready, thanks.\n\nGuido","automated_response":false,"created_at":"2016-05-23T18:29:21.413Z","updated_at":"2016-05-23T18:29:21.413Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":970965,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"","automated_response":false,"created_at":"2016-05-23T20:59:45.924Z","updated_at":"2016-05-23T20:59:45.924Z","actor":{"username":"asn","cleared":false,"url":"/asn","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"guido","url":"/guido"},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2083668,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","automated_response":false,"created_at":"2017-10-19T09:35:39.907Z","updated_at":"2017-10-19T09:35:39.907Z","first_to_agree":true,"actor":{"username":"geko","cleared":false,"url":"/geko","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":2083743,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","automated_response":false,"created_at":"2017-10-19T10:16:01.390Z","updated_at":"2017-10-19T10:16:01.390Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":2083744,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","automated_response":false,"created_at":"2017-10-19T10:16:01.436Z","updated_at":"2017-10-19T10:16:01.436Z","actor":{"username":"guido","cleared":false,"url":"/guido","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/002/983/e55b0b2324777fb7efc2de4212fd8d337ca816bd_original.jpg/fd4ecbe1e3e98c343c7717114485ace2f830f9253103d3cfa7502059868c516c"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"torproject","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}